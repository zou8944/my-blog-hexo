{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/freemind/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"themes/freemind/source/favicon.png","path":"favicon.png","modified":0,"renderable":1},{"_id":"themes/freemind/source/css/bootstrap-responsive.css","path":"css/bootstrap-responsive.css","modified":0,"renderable":1},{"_id":"themes/freemind/source/css/google-fonts.css","path":"css/google-fonts.css","modified":0,"renderable":1},{"_id":"themes/freemind/source/css/font-awesome.css","path":"css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/freemind/source/css/responsive.css","path":"css/responsive.css","modified":0,"renderable":1},{"_id":"themes/freemind/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/freemind/source/css/style.css","path":"css/style.css","modified":0,"renderable":1},{"_id":"themes/freemind/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/freemind/source/css/highlight.css","path":"css/highlight.css","modified":0,"renderable":1},{"_id":"themes/freemind/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/freemind/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/freemind/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/freemind/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/freemind/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/freemind/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/freemind/source/fonts/fontawesome-webfont.eot","path":"fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/freemind/source/fonts/fontawesome-webfont.woff","path":"fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/freemind/source/img/github-sprite.png","path":"img/github-sprite.png","modified":0,"renderable":1},{"_id":"themes/freemind/source/img/glyphicons-halflings-white.png","path":"img/glyphicons-halflings-white.png","modified":0,"renderable":1},{"_id":"themes/freemind/source/img/glyphicons-halflings.png","path":"img/glyphicons-halflings.png","modified":0,"renderable":1},{"_id":"themes/freemind/source/img/grid-18px-masked.png","path":"img/grid-18px-masked.png","modified":0,"renderable":1},{"_id":"themes/freemind/source/img/grid-baseline-20px.png","path":"img/grid-baseline-20px.png","modified":0,"renderable":1},{"_id":"themes/freemind/source/img/mycard.jpg","path":"img/mycard.jpg","modified":0,"renderable":1},{"_id":"themes/freemind/source/js/gallery.js","path":"js/gallery.js","modified":0,"renderable":1},{"_id":"themes/freemind/source/js/jquery.imagesloaded.min.js","path":"js/jquery.imagesloaded.min.js","modified":0,"renderable":1},{"_id":"themes/freemind/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/freemind/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/freemind/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":0,"renderable":1},{"_id":"themes/freemind/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":0,"renderable":1},{"_id":"themes/freemind/source/fonts/FontAwesome.otf","path":"fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/freemind/source/fonts/fontawesome-webfont.ttf","path":"fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/freemind/source/js/jquery-2.0.3.min.js","path":"js/jquery-2.0.3.min.js","modified":0,"renderable":1},{"_id":"themes/freemind/source/css/fonts/Fixedsys500c.eot","path":"css/fonts/Fixedsys500c.eot","modified":0,"renderable":1},{"_id":"themes/freemind/source/css/fonts/Fixedsys500c.otf","path":"css/fonts/Fixedsys500c.otf","modified":0,"renderable":1},{"_id":"themes/freemind/source/css/fonts/Fixedsys500c.ttf","path":"css/fonts/Fixedsys500c.ttf","modified":0,"renderable":1},{"_id":"themes/freemind/source/css/fonts/Fixedsys500c.woff","path":"css/fonts/Fixedsys500c.woff","modified":0,"renderable":1},{"_id":"themes/freemind/source/fonts/google-fonts/0AKsP294HTD-nvJgucYTaIbN6UDyHWBl620a-IRfuBk.woff","path":"fonts/google-fonts/0AKsP294HTD-nvJgucYTaIbN6UDyHWBl620a-IRfuBk.woff","modified":0,"renderable":1},{"_id":"themes/freemind/source/fonts/google-fonts/0XxGQsSc1g4rdRdjJKZrNBsxEYwM7FgeyaSgU71cLG0.woff","path":"fonts/google-fonts/0XxGQsSc1g4rdRdjJKZrNBsxEYwM7FgeyaSgU71cLG0.woff","modified":0,"renderable":1},{"_id":"themes/freemind/source/fonts/google-fonts/PIPMHY90P7jtyjpXuZ2cLD8E0i7KZn-EPnyo3HZu7kw.woff","path":"fonts/google-fonts/PIPMHY90P7jtyjpXuZ2cLD8E0i7KZn-EPnyo3HZu7kw.woff","modified":0,"renderable":1},{"_id":"themes/freemind/source/fonts/google-fonts/LKf8nhXsWg5ybwEGXk8UBQ.woff","path":"fonts/google-fonts/LKf8nhXsWg5ybwEGXk8UBQ.woff","modified":0,"renderable":1},{"_id":"themes/freemind/source/fonts/google-fonts/cj2hUnSRBhwmSPr9kS5899kZXW4sYc4BjuAIFc1SXII.woff","path":"fonts/google-fonts/cj2hUnSRBhwmSPr9kS5899kZXW4sYc4BjuAIFc1SXII.woff","modified":0,"renderable":1},{"_id":"themes/freemind/source/fonts/google-fonts/2UX7WLTfW3W8TclTUvlFyQ.woff","path":"fonts/google-fonts/2UX7WLTfW3W8TclTUvlFyQ.woff","modified":0,"renderable":1},{"_id":"themes/freemind/source/fonts/google-fonts/UyYrYy3ltEffJV9QueSi4RdbPw3QSf9R-kE0EsQUn2A.woff","path":"fonts/google-fonts/UyYrYy3ltEffJV9QueSi4RdbPw3QSf9R-kE0EsQUn2A.woff","modified":0,"renderable":1},{"_id":"themes/freemind/source/fonts/google-fonts/lILlYDvubYemzYzN7GbLkHhCUOGz7vYGh680lGh-uXM.woff","path":"fonts/google-fonts/lILlYDvubYemzYzN7GbLkHhCUOGz7vYGh680lGh-uXM.woff","modified":0,"renderable":1},{"_id":"themes/freemind/source/css/bootstrap.css.map","path":"css/bootstrap.css.map","modified":0,"renderable":1},{"_id":"themes/freemind/source/css/fonts/Fixedsys500c.svg","path":"css/fonts/Fixedsys500c.svg","modified":0,"renderable":1},{"_id":"themes/freemind/source/fonts/fontawesome-webfont.svg","path":"fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/README.MD","hash":"f5cd0ae0e3d60c4e718cb9b996fe69e17224759e","modified":1613474446000},{"_id":"source/baidu_verify_NxjgZGJjxA.html","hash":"974e2dce2b479939bc899780766ea6c6520906d1","modified":1613474446000},{"_id":"themes/freemind/LICENSE","hash":"92a6ae0476d462ede29754954abcc8ec6293e6a7","modified":1613474446000},{"_id":"themes/freemind/README.md","hash":"1b1c46f23d2d39eab2a0ec3df29f967406b61903","modified":1613474446000},{"_id":"themes/freemind/_config.yml","hash":"3fdb3f3a9f6ee154df69ade1a9b724cd8df29e43","modified":1613474446000},{"_id":"source/categories/index.md","hash":"a2f3c2718c6f0d44d792288b2abcd6b5a7ee3066","modified":1613474446000},{"_id":"source/_drafts/Celery的简单使用.md","hash":"05348e2d6d311b3234c31acf8b02df0125b4213b","modified":1719026020124},{"_id":"source/_drafts/JOOQ最佳实践.md","hash":"4b7398da550c80e6cefa26351295bce1a27c3c12","modified":1719026020123},{"_id":"source/_drafts/Reactive-Postgres-Client对比JDBC.md","hash":"38509cfe807fc4b79275cf6a69d4d2061bde4a33","modified":1719026020124},{"_id":"source/_drafts/Vertx介绍.md","hash":"2e4d814aa37c889993b12331637e13827bea9c99","modified":1613474446000},{"_id":"source/_drafts/Vertx回调地狱的解决.md","hash":"d73e2ce7f314bc6ea0813a3b02b61ecee7c573e5","modified":1613474446000},{"_id":"source/_drafts/Vertx源码解析-EventBus.md","hash":"57a656957a55a69393dec1f448cca4f998e8c94d","modified":1613474446000},{"_id":"source/_drafts/vertx与restful.md","hash":"381c076e8854c493a163d09cd570ed089f32197b","modified":1613474446000},{"_id":"source/_drafts/Vertx与响应式编程.md","hash":"f7d079702fd162ea0f723f86c4e40f1d38ed5eff","modified":1613474446000},{"_id":"source/_drafts/Sign-in-with-apple-Web登录介绍.md","hash":"fa8efd550783c2476f11f2bbd4d6668bd728316f","modified":1719026020124},{"_id":"source/_drafts/几大平台账单融合.md","hash":"701e7bdd20a1c4c4dae29affe1992a2d3e2b3c02","modified":1613474446000},{"_id":"source/_drafts/supervisor进程管理工具.md","hash":"e49c044d7f632569a07eac8f3866608703d68359","modified":1719026020124},{"_id":"source/_drafts/响应式系统.md","hash":"42aecf01d022652a2843145629b6f95c30d8a788","modified":1613474446000},{"_id":"source/_drafts/Vertx与数据库.md","hash":"3c5eaa6ced3fa27212d28cd30f0a554ec73da27f","modified":1613474446000},{"_id":"source/_drafts/响应式编程.md","hash":"74e7feec038dc3972ce153782955ee4d8647611e","modified":1613474446000},{"_id":"source/collection/index.md","hash":"22fdf3f5916e7c209c5a702158d4c70fd7fd982f","modified":1613474446000},{"_id":"source/guestbook/index.md","hash":"71de83b51b71b838e67e5937fd95d265f8094687","modified":1613474446000},{"_id":"source/tags/index.md","hash":"0092dcff6e55b833c7e7d8461705c0e34372a75f","modified":1613474446000},{"_id":"themes/freemind/languages/default.yml","hash":"155f627b68439b096421516fe742b885a6983c1f","modified":1613474446000},{"_id":"themes/freemind/languages/zh-CN.yml","hash":"8d4b269767b25d1271805de714844cefc344fd1b","modified":1613474446000},{"_id":"themes/freemind/languages/zh-TW.yml","hash":"985c868d3710a8eaa35672fd48fd98a32aea1634","modified":1613474446000},{"_id":"themes/freemind/languages/pt-BR.yml","hash":"fa8333f571440de5562918728ff2d206f7960269","modified":1613474446000},{"_id":"themes/freemind/layout/categories.ejs","hash":"9ea0e589b02de6ae6ddbd5ca699b52471901a7b9","modified":1613474446000},{"_id":"themes/freemind/layout/archive.ejs","hash":"c97be36b33bb44957778587f00c978f2d28016f8","modified":1613474446000},{"_id":"themes/freemind/layout/index.ejs","hash":"34656bff868d0e8afed13ca722d138bac0b01da9","modified":1613474446000},{"_id":"themes/freemind/layout/layout.ejs","hash":"288577e8d379364126679ae8466bee90b62bbda8","modified":1613474446000},{"_id":"themes/freemind/layout/page.ejs","hash":"21612a42b29cb20f106bc2716c598e69db142750","modified":1613474446000},{"_id":"themes/freemind/layout/post.ejs","hash":"dd2ad444d8a916a4f3fbcfb6e1b5f19890429ec4","modified":1613474446000},{"_id":"themes/freemind/layout/tags.ejs","hash":"039b99abfedabe5646f6d7a2ce275e0d5afd42f2","modified":1613474446000},{"_id":"source/about/index.md","hash":"fbed36edafdd892dc37fba9bf156159871a0cb9f","modified":1719040181134},{"_id":"themes/freemind/source/favicon.ico","hash":"bbfe456d427483c27cda0bd10fec5cc1f848c1f1","modified":1613474446000},{"_id":"themes/freemind/source/favicon.png","hash":"3247c02b3e3516aca534bcfa7a7c34b30defa298","modified":1613474446000},{"_id":"source/_posts/Common FileUpload介绍.md","hash":"795c8c174ba11d048f743f8855f3a418eb9715f3","modified":1613474446000},{"_id":"source/_posts/Git基础知识.md","hash":"7fc192d1b9c538892f5131a61bfc07f23b6a61b7","modified":1613474446000},{"_id":"source/_posts/Kotlin协程-使用篇.md","hash":"bf9ec796355b252869bc5f96ead1365df337a428","modified":1719026060453},{"_id":"source/_posts/Kubernetes - ConfigMap和Secret.md","hash":"4d32127e5a50033dd9ba843c6d779a979beee6a0","modified":1613474446000},{"_id":"source/_posts/Kubernetes - Deployment.md","hash":"0cb346b14bcdfef8dfbdc729d631492ee236b414","modified":1613474446000},{"_id":"source/_posts/Kubernetes - POD.md","hash":"ca0ca68af7ec2cca77e25dabc4564090fb4fb92d","modified":1613474446000},{"_id":"source/_posts/Kubernetes - StatefulSet.md","hash":"fefd0e88d65fdf38b0cfa9cbee009e16b425e1c7","modified":1613474446000},{"_id":"source/_posts/Kubernetes - Service.md","hash":"b70aa5922d998beb2631c9af2ed9a6ea54090743","modified":1613474446000},{"_id":"source/_posts/Kubernetes - 卷.md","hash":"4edf66c1db0838948b722aea6718db992c6d16e1","modified":1613474446000},{"_id":"source/_posts/Kubernetes - 概览.md","hash":"04dc02074e778a809cc2531741a9562faf12707c","modified":1613474446000},{"_id":"source/_posts/Kubernetes - 访问pod元数据及其它资源.md","hash":"0c5d11688343c0ef1abd412339a932290ab30e3d","modified":1613474446000},{"_id":"source/_posts/Python-日志.md","hash":"a7dcc8d55cbcc8a82ed0e75bd8a7f21b03b6019d","modified":1719026020126},{"_id":"source/_posts/Postgresql的Listen-Notify机制.md","hash":"4324395265c6aed25d60389924ac5f11fc93b300","modified":1719026020127},{"_id":"source/_posts/Sign-in-with-apple-IOS登录后端介绍.md","hash":"2cd0267ed376d42ea30cb5007ec7cfbc7237cdbf","modified":1719026020126},{"_id":"source/_posts/Spring Webflow - EL表达式.md","hash":"e960a27ca517bbd8641a70b5fb668294e24594a1","modified":1613474446000},{"_id":"source/_posts/Spring Webflow - Action.md","hash":"e134ffed2669cc85380bd30bbbe89e2638471ed8","modified":1613474446000},{"_id":"source/_posts/Spring Webflow - 前言.md","hash":"309bdc8870b4c78a70d74dcb74e5032bde6cfa77","modified":1613474446000},{"_id":"source/_posts/Spring Webflow - 基础.md","hash":"0182ccdd5379f92a54eb977060144e4fad902749","modified":1613474446000},{"_id":"source/_posts/Spring Webflow - 视图状态.md","hash":"7194f60b0a0e583b9df556872148b37855f84b2e","modified":1613474446000},{"_id":"source/_posts/Spring Webflow - 配置.md","hash":"3e56e3d7115ce753c0ff383d9e22bc6c2d8a1e67","modified":1613474446000},{"_id":"source/_posts/Spring-Webflow - 第一个Flow.md","hash":"7b5919b45888627f5baf31dd03bfcb9b12cf75a9","modified":1613474446000},{"_id":"source/_posts/Vertx - 接管OpenAPI的400响应.md","hash":"40f8ce2a3463ec98053a3bb606d269595f446f77","modified":1719026020129},{"_id":"source/_posts/Vertx缓存Future.md","hash":"46562ed16893998c5f3230145a3c861714459dfc","modified":1719026020127},{"_id":"source/_posts/java时间-java-time介绍.md","hash":"7039da222bcd33d5fca2975725e3856d7298c46d","modified":1719026020127},{"_id":"source/_posts/pipenv-python包管理和虚拟环境工具.md","hash":"17b363ecb4adaaeb72622569a873e579b50b5ee3","modified":1719026020127},{"_id":"source/_posts/使用Django从零搭建一个小型站点.md","hash":"3def07b84b29c0f55c9477efe7542e2f8968c0c4","modified":1613474446000},{"_id":"source/_posts/域名解析DNS.md","hash":"9ec422380591fc7bcd8517ed987986ac2d46271e","modified":1613474446000},{"_id":"source/_posts/基于frp构建内网穿透.md","hash":"7b7e2d5cf102c12e9eb4895f17161407bcc7ad9b","modified":1719026020128},{"_id":"source/_posts/如何将插件发布到Maven中央库.md","hash":"a823560bda4542101d306f4c2c565ee322617ff6","modified":1719026020128},{"_id":"source/_posts/技术巡礼 - Akka和Lightend.md","hash":"f9b12b7087636ffd5dd9e35d71b898a9c4ce9554","modified":1613474446000},{"_id":"source/_posts/如何编写一个Maven插件.md","hash":"00c63c59dac8ecbeda31e3c85c77556aec14d6e1","modified":1719026020128},{"_id":"source/_posts/我有点想要写博客了.md","hash":"7a47b231283fb5a90c469adb9cdf2c4bdb93f67f","modified":1613474446000},{"_id":"source/_posts/技术巡礼 - AngularJS.md","hash":"41816c6b1ee6d9931fcb13869acab54c8f0e3c02","modified":1613474446000},{"_id":"source/_posts/推荐系统 - 基于用户行为数据的推荐.md","hash":"dd366def749d3a6cabd49775094535a9d2e974a2","modified":1613474446000},{"_id":"source/_posts/技术巡礼 - SockJS.md","hash":"da0f8d6feaf0de2cf9b1159684fc283cba9866c8","modified":1613474446000},{"_id":"source/_posts/推荐系统 - 概述.md","hash":"3c8aeeb55f1899b733cca8c1deb1eb59d9b0d6e3","modified":1613474446000},{"_id":"source/_posts/日常flag - 20190915.md","hash":"9d9be311edc0effa21f48ce8607d74b232811bbb","modified":1613474446000},{"_id":"source/_posts/浏览器指纹介绍及挑战.md","hash":"62c5e496f4297345b572e31d42557a1c20a3e996","modified":1613474446000},{"_id":"source/_posts/深入了解Nginx的server和location的匹配算法.md","hash":"1c68c69b6b7a7b1db0723efdc358cd91fb4d2151","modified":1719026020129},{"_id":"source/_posts/理解Java-IO.md","hash":"8f892972a7fb9371c970a5cbd09381f90cf8abf0","modified":1719026020129},{"_id":"source/_posts/用Prometheus和Grafana监控你的服务器.md","hash":"919b09715acb6d35fa0da4d34ea393fcfc2ddb8d","modified":1719026020129},{"_id":"source/_posts/读书笔记 - RxJava.md","hash":"63652af6a90c0e3d99b8fef74cfdab2ff04eb3bb","modified":1613474446000},{"_id":"source/_posts/通过几个问题了解Http协议.md","hash":"bad0dc0e0bd799e4a2bfaf485887ea086aca4958","modified":1613474446000},{"_id":"source/_posts/那些递归的计算机术语.md","hash":"284ee9361c298457f472ebecb362d52df251f238","modified":1719026020130},{"_id":"source/_drafts/Celery的简单使用/image-20191205201437918.png","hash":"84dcc484fd5cf0b5ec589fb84b07f851262c5c8d","modified":1613474446000},{"_id":"source/collection/images/1569741148684.png","hash":"5ac6573db6fa5925b98e67b7243771bc2f66ca80","modified":1613474446000},{"_id":"source/collection/images/1569741183024.png","hash":"c53f33fdde144c206d35964dcf57aefe4b619e17","modified":1613474446000},{"_id":"source/collection/images/1569741218418.png","hash":"c53f33fdde144c206d35964dcf57aefe4b619e17","modified":1613474446000},{"_id":"source/collection/images/1569741173283.png","hash":"69eefbb0293be87bb0aeb100f25fcd87e3af4a29","modified":1613474446000},{"_id":"themes/freemind/layout/_widget/search.ejs","hash":"620dd8a93a9f0fca63f6f0b520cf192ce7b5a645","modified":1613474446000},{"_id":"themes/freemind/layout/_widget/tagcloud.ejs","hash":"2bb6f4c3b2c10bc107f2d216bda34339ca045338","modified":1613474446000},{"_id":"themes/freemind/layout/_widget/category.ejs","hash":"9582012806de184f419a2230aa52ca20915a4115","modified":1613474446000},{"_id":"themes/freemind/layout/_widget/recent_posts.ejs","hash":"8d1018d6b4b9c83a58efc11a2ceef86a2bbbeb17","modified":1613474446000},{"_id":"themes/freemind/layout/_widget/links.ejs","hash":"c0452a56e4513efe03867734f5fbcb6715f9a852","modified":1613474446000},{"_id":"themes/freemind/layout/_partial/after_footer.ejs","hash":"cc2b3e840551930a178bac4ff5061a4b14302ea9","modified":1613474446000},{"_id":"themes/freemind/layout/_partial/archive.ejs","hash":"a691c9d3a2ca1ca040c25073d8202a51859b6289","modified":1613474446000},{"_id":"themes/freemind/layout/_partial/footer.ejs","hash":"9eb23eefa081e36cf18f9d5332545fe4cbee1388","modified":1613474446000},{"_id":"themes/freemind/layout/_partial/index.ejs","hash":"6cb906da2b19e4abad02a321313b7fb76ae2bb8b","modified":1613474446000},{"_id":"themes/freemind/layout/_partial/article.ejs","hash":"130c2ddf9092aceec740c691cffd74abfabfcee8","modified":1613474446000},{"_id":"themes/freemind/layout/_partial/index_pagination.ejs","hash":"fe70eeb0f11d918f230baadeadedbce3c847392d","modified":1613474446000},{"_id":"themes/freemind/layout/_partial/head.ejs","hash":"3e184a2293cbd45ad43b0f65592b21c090c626e4","modified":1613474446000},{"_id":"themes/freemind/layout/_partial/navigation.ejs","hash":"b4d28b4948e2c7f06ef1eca1a81ade5a58749eac","modified":1613474446000},{"_id":"themes/freemind/layout/_partial/search.ejs","hash":"a7c526c07a8af040ba285dc63f267004ce211dce","modified":1613474446000},{"_id":"themes/freemind/layout/_partial/sidebar.ejs","hash":"862ff700568ec5a00f222131b353475d0a3f2a9c","modified":1613474446000},{"_id":"themes/freemind/source/css/.emacs.desktop","hash":"3155b8ebc9cd3895cf9d0934ecc230dc0601489e","modified":1613474446000},{"_id":"themes/freemind/source/css/bootstrap-responsive.css","hash":"ea29a73addac5004ba4e7e4860e895cf15a5aa31","modified":1613474446000},{"_id":"themes/freemind/source/css/google-fonts.css","hash":"06db66e315b47f844fb208b50e5710606360b142","modified":1613474446000},{"_id":"themes/freemind/source/css/font-awesome.css","hash":"180959029f82028c2100b7eeec7665412a49e588","modified":1613474446000},{"_id":"themes/freemind/source/css/responsive.css","hash":"30f6a26aa0a5368d24a68575eb3fe254de7b92d2","modified":1613474446000},{"_id":"themes/freemind/source/fancybox/blank.gif","hash":"4ffebfc1255c0da73aab342450a9ee09fcaccb86","modified":1613474446000},{"_id":"themes/freemind/source/css/style.css","hash":"63846eb7fa6664b361ce1411efc6d46921c47dd5","modified":1613474446000},{"_id":"themes/freemind/source/fancybox/fancybox_loading.gif","hash":"4fbaf63664f65a42bef60289c887cd61a925ce4c","modified":1613474446000},{"_id":"themes/freemind/source/css/highlight.css","hash":"77c38f70b3f3e0a10ae24126f4561f7f2e4f025b","modified":1613474446000},{"_id":"themes/freemind/source/fancybox/fancybox_loading@2x.gif","hash":"381e91e67e85bfda09ce8b88205d93d9a7d20d4d","modified":1613474446000},{"_id":"themes/freemind/source/fancybox/fancybox_overlay.png","hash":"beb714da455e5dbdbf7b2ed466ff4308c103addb","modified":1613474446000},{"_id":"themes/freemind/source/fancybox/fancybox_sprite.png","hash":"0657b6b574bafc4c819c7d6c3bc5dd7205c8eee7","modified":1613474446000},{"_id":"themes/freemind/source/fancybox/fancybox_sprite@2x.png","hash":"ecf1523aefe416a4cc901ab4cda5d488e3d9cd76","modified":1613474446000},{"_id":"themes/freemind/source/fancybox/jquery.fancybox.css","hash":"cbb69ef9748bf92edc3eb4b269b77ad25465d049","modified":1613474446000},{"_id":"themes/freemind/source/fancybox/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1613474446000},{"_id":"themes/freemind/source/fonts/fontawesome-webfont.eot","hash":"0183979056f0b87616cd99d5c54a48f3b771eee6","modified":1613474446000},{"_id":"themes/freemind/source/fonts/fontawesome-webfont.woff","hash":"7d65e0227d0d7cdc1718119cd2a7dce0638f151c","modified":1613474446000},{"_id":"themes/freemind/source/img/github-sprite.png","hash":"7e3ba97164323840fbe3a175b8535087ece93711","modified":1613474446000},{"_id":"themes/freemind/source/img/glyphicons-halflings-white.png","hash":"3f6acfb147851b261f24b030a840b758c4667e26","modified":1613474446000},{"_id":"themes/freemind/source/img/glyphicons-halflings.png","hash":"0b92d4a64699af327eff00b727f1aa46361debfa","modified":1613474446000},{"_id":"themes/freemind/source/img/grid-18px-masked.png","hash":"2a5b89bc935f2a53870f8788b573971dc3ac7358","modified":1613474446000},{"_id":"themes/freemind/source/img/grid-baseline-20px.png","hash":"f51efa3d9ee45c6053bb76244fdf7dd8967b7b6b","modified":1613474446000},{"_id":"themes/freemind/source/img/mycard.jpg","hash":"96227b4fd1ba9fb4510ad6b536930f1a28d02ebb","modified":1613474446000},{"_id":"themes/freemind/source/js/gallery.js","hash":"10cad81731825178f3d30b80a2694a377c1fb7a6","modified":1613474446000},{"_id":"themes/freemind/source/js/jquery.imagesloaded.min.js","hash":"3eb6381d2ed4b706020e4be5aff024aab4bcabc5","modified":1613474446000},{"_id":"themes/freemind/source/js/main.js","hash":"e3fcd795564533a3984b0ce327bd8dff44145f89","modified":1613474446000},{"_id":"themes/freemind/source/js/search.js","hash":"a882244488031de498176fc6af35cea2a13c7a18","modified":1613474446000},{"_id":"themes/freemind/source/js/bootstrap.min.js","hash":"5814e91bb6276f4de8b7951c965f2f190a03978d","modified":1613474446000},{"_id":"source/_posts/Kotlin协程-使用篇/image-20200530154420916.png","hash":"553b4c07e90d952f1887591b55dda119f27f6424","modified":1613474446000},{"_id":"source/_posts/Kotlin协程-使用篇/image-20200530153221730.png","hash":"4ac7a37e921fb4aacf4bfb2a05cbd579a2352b7d","modified":1613474446000},{"_id":"source/_posts/Kotlin协程-使用篇/image-20200530165243662.png","hash":"27ee8e891254fe0a26d9a9ccd36bba42cef6a5cd","modified":1613474446000},{"_id":"source/_posts/Kotlin协程-使用篇/image-20200530165158464.png","hash":"0bd7636505a805f07ba623ed387c0ee9836197fa","modified":1613474446000},{"_id":"source/_posts/Kubernetes - ConfigMap和Secret/image-20191024210340290.png","hash":"b4712f2927f93b93b5e893536d2cd80922373c70","modified":1613474446000},{"_id":"source/_posts/Kubernetes - ConfigMap和Secret/image-20191024202924093.png","hash":"031846de693770e065e138115f7fabb29a893974","modified":1613474446000},{"_id":"source/_posts/Kubernetes - 访问pod元数据及其它资源/image-20191026103637438.png","hash":"f159b07e51d1669ad3e6569d67c15ea38973086e","modified":1613474446000},{"_id":"source/_posts/Kubernetes - 访问pod元数据及其它资源/image-20191026103845268.png","hash":"333927dccd5affab09ef5cf55994a1fee0875870","modified":1613474446000},{"_id":"source/_posts/Kubernetes - 访问pod元数据及其它资源/image-20191026103024214.png","hash":"d74d59ad2fcdae30c19496ece62e2a5d3836cad7","modified":1613474446000},{"_id":"source/_posts/Kubernetes - 访问pod元数据及其它资源/image-20191026103733430.png","hash":"878df26a69f98275d8b3695c514635609c88adcf","modified":1613474446000},{"_id":"source/_posts/Kubernetes - 访问pod元数据及其它资源/image-20191026103807750.png","hash":"71607bb9ddd902b9aaf20c9e9db78dbc08d094bc","modified":1613474446000},{"_id":"source/_posts/Kubernetes - 访问pod元数据及其它资源/image-20191026110236335.png","hash":"b8d6ab0219bbe74b861aba485458c406e6c02b25","modified":1613474446000},{"_id":"source/_posts/Kubernetes - 访问pod元数据及其它资源/image-20191026111636241.png","hash":"8917c85ea715c4243b6fbd6516e43f26df279242","modified":1613474446000},{"_id":"source/_posts/Kubernetes - 访问pod元数据及其它资源/image-20191026110731625.png","hash":"a42027cc9b2fc54a0c048464ecaa631d9c5a04ae","modified":1613474446000},{"_id":"source/_posts/Kubernetes - 访问pod元数据及其它资源/image-20191026112834243.png","hash":"01e595d7becb9d605dcb7b253acac6e83fb8013d","modified":1613474446000},{"_id":"source/_posts/Python-日志/image-20200307193416476.png","hash":"8e3c0e456cfc46fb9c5c85978991259a5308361d","modified":1613474446000},{"_id":"source/_posts/Sign-in-with-apple-IOS登录后端介绍/image-20200328175122832.png","hash":"b9469b4413e7da0587558da0ea7d8b32becb7c9c","modified":1613474446000},{"_id":"source/_posts/Sign-in-with-apple-IOS登录后端介绍/image-20200328184605411.png","hash":"f9772b470f014f6aa43b37696a30d06fcf6eb050","modified":1613474446000},{"_id":"source/_posts/Sign-in-with-apple-IOS登录后端介绍/image-20200328193546162.png","hash":"fe0bdf8cc37791aac2da673ca6f745d76d7e2163","modified":1613474446000},{"_id":"source/_posts/Sign-in-with-apple-IOS登录后端介绍/image-20200328193527518.png","hash":"04110cc8f7b6ad9ec4fb7755fb34c16b668ee265","modified":1613474446000},{"_id":"source/_posts/Sign-in-with-apple-IOS登录后端介绍/image-20200328193610272.png","hash":"b51c9fb0144f766ce5283d9b722689817f77351e","modified":1613474446000},{"_id":"source/_posts/Spring-Webflow - 第一个Flow/20180906212548121.png","hash":"8e06b7660aa416ed2f5c52697abc4012d3af59c4","modified":1613474446000},{"_id":"source/_posts/Spring-Webflow - 第一个Flow/20180906213226568.png","hash":"c41f9272e18766632ba10675e4c75e2900d6a0b8","modified":1613474446000},{"_id":"source/_posts/Spring-Webflow - 第一个Flow/20180906215538433.jpeg","hash":"9e672548ca8f300a4a6d609cd5b7a0bb88e36b91","modified":1613474446000},{"_id":"source/_posts/Vertx - 接管OpenAPI的400响应/image-20200314115204080.png","hash":"9c083bcfac73ab54ceb135665157fec43de0f5c2","modified":1613474446000},{"_id":"source/_posts/pipenv-python包管理和虚拟环境工具/image-20191207113738047.png","hash":"1bafedfd2467975aa3e4f86e0958c3f9a9c73ae2","modified":1613474446000},{"_id":"source/_posts/Vertx - 接管OpenAPI的400响应/image-20200314115352490.png","hash":"e7b3b4752534cfcb26254e90dac0662fbaa2b6d2","modified":1613474446000},{"_id":"source/_posts/pipenv-python包管理和虚拟环境工具/image-20191207113857861.png","hash":"4c18767d2c84c380a3708baa45d6133d1e7e61e8","modified":1613474446000},{"_id":"source/_posts/pipenv-python包管理和虚拟环境工具/image-20191207114424866.png","hash":"822e0f63df3f4f30feaff08acee3af314839e3fb","modified":1613474446000},{"_id":"source/_posts/pipenv-python包管理和虚拟环境工具/image-20191207114905560.png","hash":"1cdd6e5915610f52e6b53de871b12af0f4d1b630","modified":1613474446000},{"_id":"source/_posts/pipenv-python包管理和虚拟环境工具/image-20191209144953109.png","hash":"5dea4018d7da9aaff4a5f854932dee9bba34b22f","modified":1613474446000},{"_id":"source/_posts/pipenv-python包管理和虚拟环境工具/image-20191209145108836.png","hash":"979290e825ad41df9ba561694d7f770b997adc11","modified":1613474446000},{"_id":"source/_posts/pipenv-python包管理和虚拟环境工具/image-20191209145341432.png","hash":"954dba54107938707b56c2493f20ec5d1ef7b7d7","modified":1613474446000},{"_id":"source/_posts/域名解析DNS/image-20191201154232500.png","hash":"a79f117c9fe5d348ba14c1d5d3ef92ec1291ef8d","modified":1613474446000},{"_id":"source/_posts/域名解析DNS/image-20191201154201525.png","hash":"d4fdeac41a54918d777902bc3ac14c99422edf69","modified":1613474446000},{"_id":"source/_posts/域名解析DNS/image-20191201155715623.png","hash":"1c5f35e1bea8ceb6ac29c944b26a2ef06db26b0c","modified":1613474446000},{"_id":"source/_posts/域名解析DNS/image-20191201161114768.png","hash":"95e86471b4db43eef11699818aebdd1f30703e38","modified":1613474446000},{"_id":"source/_posts/域名解析DNS/image-20191201155650946.png","hash":"3bec8b0fdc229e3139d6778e9c832c6297a9fb0e","modified":1613474446000},{"_id":"source/_posts/如何将插件发布到Maven中央库/image-20200229131357158.png","hash":"d9b15d6ba2842d28dafc1b39d62eb954e70f261f","modified":1613474446000},{"_id":"source/_posts/域名解析DNS/image-20191201162003135.png","hash":"b79189fe2e27e332ae4168f4157235434c1c19f1","modified":1613474446000},{"_id":"source/_posts/如何将插件发布到Maven中央库/image-20200229174020789.png","hash":"43d2d6b39249e666fb641896919e5c436e589faa","modified":1613474446000},{"_id":"source/_posts/如何将插件发布到Maven中央库/image-20200229174034285.png","hash":"abe5ec1bb3147f715c00d01916b66df24a3ab129","modified":1613474446000},{"_id":"source/_posts/如何将插件发布到Maven中央库/image-20200229181853303.png","hash":"c8fb48826391dc4904f0042207dafc82136e2d94","modified":1613474446000},{"_id":"source/_posts/如何将插件发布到Maven中央库/image-20200229190119427.png","hash":"6a45aa1876d79b4d349b45527886a76becd2ee04","modified":1613474446000},{"_id":"source/_posts/基于frp构建内网穿透/image-20200223184119014.png","hash":"afc76ac4ce1ab118619783b225d61943fe95de8e","modified":1613474446000},{"_id":"source/_posts/基于frp构建内网穿透/image-20200223184632196.png","hash":"afc76ac4ce1ab118619783b225d61943fe95de8e","modified":1613474446000},{"_id":"source/_posts/如何编写一个Maven插件/image-20200229173829978.png","hash":"b686896d004e4729280c7d0fc1c900a485fcffaa","modified":1613474446000},{"_id":"source/_posts/基于frp构建内网穿透/image-20200223201440732.png","hash":"3d05c018fded45133bc38be40e02e5ee44d70306","modified":1613474446000},{"_id":"source/_posts/基于frp构建内网穿透/image-20200223200953292.png","hash":"d43467ea57cc4a4b091c1409456e6db7254aad25","modified":1613474446000},{"_id":"source/_posts/如何编写一个Maven插件/image-20200229173859472.png","hash":"83fb706a4b525101e84819daf82b5ed2851bca39","modified":1613474446000},{"_id":"source/_posts/技术巡礼 - AngularJS/JsFrameWorkComparison.jpeg","hash":"60684d8cad127f7fec992e08a1a1985f30c07420","modified":1613474446000},{"_id":"source/_posts/理解Java-IO/image-20200419135156288.png","hash":"f805750e966b34fe431a0ede508a0e117f4db59b","modified":1613474446000},{"_id":"source/_posts/理解Java-IO/image-20200419140118975.png","hash":"1192629b5fd8819a34c9719e7a0aac44703ab91c","modified":1613474446000},{"_id":"source/_posts/用Prometheus和Grafana监控你的服务器/image-20200321213622180.png","hash":"e609da73d28ea68712f2ca989ae3b1e076152f0b","modified":1613474446000},{"_id":"source/_posts/用Prometheus和Grafana监控你的服务器/image-20200321222952432.png","hash":"6fcf079911b07070b401035528bf39977f4e05a0","modified":1613474446000},{"_id":"source/_posts/用Prometheus和Grafana监控你的服务器/image-20200321222820888.png","hash":"c73bdbdcba27509762e7feb3386ef928bdfd469a","modified":1613474446000},{"_id":"source/_posts/用Prometheus和Grafana监控你的服务器/image-20200321222203367.png","hash":"10fb298bdc21d61bd75a6cdc811db4ee9f8f9bad","modified":1613474446000},{"_id":"source/_posts/用Prometheus和Grafana监控你的服务器/image-20200321223057788.png","hash":"c5e5039e75ae4da2503ef671768a205f461d5304","modified":1613474446000},{"_id":"source/_posts/用Prometheus和Grafana监控你的服务器/image-20200321223108622.png","hash":"091d48c6b302db4f31b66e7890225978b4c120cf","modified":1613474446000},{"_id":"source/_posts/用Prometheus和Grafana监控你的服务器/image-20200321223828312.png","hash":"93f4271912f131a06daed238f7e59676c47b312d","modified":1613474446000},{"_id":"source/_posts/用Prometheus和Grafana监控你的服务器/image-20200321223832988.png","hash":"93f4271912f131a06daed238f7e59676c47b312d","modified":1613474446000},{"_id":"source/_posts/用Prometheus和Grafana监控你的服务器/image-20200321223803850.png","hash":"7cb3a6c35f26098bac319d298a0b49ede730a1ad","modified":1613474446000},{"_id":"source/_posts/用Prometheus和Grafana监控你的服务器/image-20200321223310983.png","hash":"7716232f1878e0c10035d461fd5946e793acd437","modified":1613474446000},{"_id":"source/_posts/用Prometheus和Grafana监控你的服务器/image-20200321224240393.png","hash":"e37ac198c387494bcfeb8c1a604379b2e21ca858","modified":1613474446000},{"_id":"source/_posts/用Prometheus和Grafana监控你的服务器/image-20200321224015143.png","hash":"ff83526c79897633c3b9172d7615d91736281b59","modified":1613474446000},{"_id":"source/_posts/用Prometheus和Grafana监控你的服务器/image-20200321224349682.png","hash":"32d9d632434a678a52b7b20534965f3275441e19","modified":1613474446000},{"_id":"source/_posts/读书笔记 - RxJava/1564822583394.png","hash":"1ce10d5c470cb6a597648e581c7917acb8e61e62","modified":1613474446000},{"_id":"source/_posts/读书笔记 - RxJava/1564823342178.png","hash":"0077fdc1795f40f4ac40d76575327f83479a5584","modified":1613474446000},{"_id":"source/_posts/读书笔记 - RxJava/1564824218864.png","hash":"a9a51de5d2aa4e25ae21bff6df7064915b29e372","modified":1613474446000},{"_id":"source/_posts/读书笔记 - RxJava/1564825542157.png","hash":"d5a36ade8dd2f56ce3986c68167765c1f77eb798","modified":1613474446000},{"_id":"source/_posts/读书笔记 - RxJava/1564823975876.png","hash":"c8d7b4ce7e10042f48bf52a37fd69b9ba86145b7","modified":1613474446000},{"_id":"themes/freemind/source/css/bootstrap.min.css","hash":"468c662a80ef582fa1ae492ebe5d415c9b275818","modified":1613474446000},{"_id":"themes/freemind/source/fonts/FontAwesome.otf","hash":"6270a4a561a69fef5f5cc18cdf9efc256ec2ccbe","modified":1613474446000},{"_id":"themes/freemind/source/fonts/fontawesome-webfont.ttf","hash":"6225ccc4ec94d060f19efab97ca42d842845b949","modified":1613474446000},{"_id":"themes/freemind/source/js/jquery-2.0.3.min.js","hash":"28daf1b2a995cc4de81154a9a9ebdbb98f7c9997","modified":1613474446000},{"_id":"source/_posts/Kubernetes - Deployment/image-20191027105535321.png","hash":"72725b05352c7e261c16c11543233509f8aed560","modified":1613474446000},{"_id":"source/_posts/Kubernetes - Deployment/image-20191027110812026.png","hash":"833f4cae06fedd11ffe795b59850508ee395ca90","modified":1613474446000},{"_id":"source/_posts/Kubernetes - Deployment/image-20191027120809966.png","hash":"b03e573761b40c9e9ed6be51c6acf66cb1beaf5f","modified":1613474446000},{"_id":"source/_posts/Kubernetes - Deployment/image-20191027121408237.png","hash":"62e6f4e6a394879148c4196b7bba564d9b6e85e4","modified":1613474446000},{"_id":"source/_posts/Kubernetes - POD/1571565351148.png","hash":"b2cb75819baccfb87323e2f4f9a1ca760c428680","modified":1613474446000},{"_id":"source/_posts/Kubernetes - POD/1571545693737.png","hash":"272302da2bae224dc3c45231a8cf9ce02b84382f","modified":1613474446000},{"_id":"source/_posts/Kubernetes - Service/1571650418897.png","hash":"e8a47081ebe633839297209a321fbe76b4dc9918","modified":1613474446000},{"_id":"source/_posts/Kubernetes - StatefulSet/image-20191027173409275.png","hash":"c6e2514bb46ca3adc8c585249dcd058847e193b6","modified":1613474446000},{"_id":"source/_posts/Kubernetes - StatefulSet/image-20191027175851844.png","hash":"65b7fcf142be076d2c7e570c538154e4faa2fbac","modified":1613474446000},{"_id":"source/_posts/Kubernetes - Service/1571731896639.png","hash":"8edd9ab860e044d69dcdb74c2ecc03519b3c45bc","modified":1613474446000},{"_id":"source/_posts/Kubernetes - 卷/1571731921904.png","hash":"4dfb4156aa52860114b2f71177b2b00bb87f9aaf","modified":1613474446000},{"_id":"source/_posts/Kubernetes - 卷/1571734843172.png","hash":"0bc0b6e3f853e3f324f56d1af970c4dcc01dc25f","modified":1613474446000},{"_id":"source/_posts/Kubernetes - 卷/1571746250551.png","hash":"a89b3ab3745a23a8a2356772e4eb0209bd98dfb3","modified":1613474446000},{"_id":"source/_posts/Kubernetes - 访问pod元数据及其它资源/image-20191026095824633.png","hash":"f3aba3a20609dbe06c4cfe86bfcb8423b74b1753","modified":1613474446000},{"_id":"source/_posts/Kubernetes - 访问pod元数据及其它资源/image-20191026113239941.png","hash":"00b56f7eb88d5511cd27de5c7b971e2292dddf12","modified":1613474446000},{"_id":"source/_posts/pipenv-python包管理和虚拟环境工具/image-20191207114240569.png","hash":"18578bcd65e61be9f674293d7438148c50401a61","modified":1613474446000},{"_id":"source/_posts/pipenv-python包管理和虚拟环境工具/image-20191209145003311.png","hash":"0d7aaa45f3f87aece13acfccde1af6b69598c14a","modified":1613474446000},{"_id":"source/_posts/域名解析DNS/image-20191201165045751.png","hash":"a98eff77dad9c75b243389306b4cf116ed390c9d","modified":1613474446000},{"_id":"source/_posts/如何将插件发布到Maven中央库/image-20200229133647975.png","hash":"d7af2f4c0d109db0ea1a14179ef59f67acfb3ea6","modified":1613474446000},{"_id":"source/_posts/如何将插件发布到Maven中央库/image-20200229174512183.png","hash":"c84e2216842eb0ba99527b0e5c742f9ed1b14e5c","modified":1613474446000},{"_id":"source/_posts/基于frp构建内网穿透/image-20200223182842911.png","hash":"808ca1d516c0c446da522bbd95a486116406808b","modified":1613474446000},{"_id":"source/_posts/基于frp构建内网穿透/image-20200223184719862.png","hash":"b03784956c0d90df557042226a447c12dc7a9856","modified":1613474446000},{"_id":"source/_posts/理解Java-IO/image-20200419135442933.png","hash":"a9e7419ddcb50dcd3ea15f625629e4208ca116b8","modified":1613474446000},{"_id":"source/_posts/理解Java-IO/image-20200419140010012.png","hash":"8670ab2321ebd3aa74b09666abec5251cf1cddf9","modified":1613474446000},{"_id":"source/_posts/理解Java-IO/image-20200419135918743.png","hash":"e6337710e3ebb90cbf0cf4a9317405771c864035","modified":1613474446000},{"_id":"source/_posts/理解Java-IO/image-20200419135944879.png","hash":"4b223f3d02d349f8ddc9bb61d70d34968ab55dc3","modified":1613474446000},{"_id":"source/_posts/理解Java-IO/image-20200419140042409.png","hash":"1579da1d344265443dc08d30adaa9856a94d4afc","modified":1613474446000},{"_id":"source/_posts/理解Java-IO/image-20200419140100782.png","hash":"cfa187dfb868850172e5e5f5bad29def86f9a33a","modified":1613474446000},{"_id":"source/_posts/用Prometheus和Grafana监控你的服务器/image-20200321220315917.png","hash":"1197523f127a92101dfa5ecec9750f2bdb4efa85","modified":1613474446000},{"_id":"source/_posts/读书笔记 - RxJava/1564802038820.png","hash":"f207e2a2fc392e6630b4c10648c86adc4955cdb7","modified":1613474446000},{"_id":"source/_posts/读书笔记 - RxJava/1564823248295.png","hash":"4db03cf707a8509d4ae6ed417e07f20f1952d987","modified":1613474446000},{"_id":"source/_posts/读书笔记 - RxJava/switch.c.png","hash":"2dec2df4de7ee8710eab47829f8b2b25e55f2b58","modified":1613474446000},{"_id":"themes/freemind/layout/_partial/post/category.ejs","hash":"54c22e9df09949f59298b21bb2fd55b01fa68845","modified":1613474446000},{"_id":"themes/freemind/layout/_partial/post/analytics.ejs","hash":"31a0a3e5bc616b847c1ed82293fb3a3fc97054be","modified":1613474446000},{"_id":"themes/freemind/layout/_partial/post/comment.ejs","hash":"56ed478bcc0820dcbb5c40942079124a7af5f3bf","modified":1613474446000},{"_id":"themes/freemind/layout/_partial/post/entry.ejs","hash":"af003040bc93a1f0f710ab6a81db22a512f03646","modified":1613474446000},{"_id":"themes/freemind/layout/_partial/post/comment_footer.ejs","hash":"fefc355eb4d61d08ffca7f6439fecb146696265e","modified":1613474446000},{"_id":"themes/freemind/layout/_partial/post/meta.ejs","hash":"a9660d5c12204ae80d75443ebdc513184320c98d","modified":1613474446000},{"_id":"themes/freemind/layout/_partial/post/pagination.ejs","hash":"7dbeff1fbb48f8a1f180db2671b28bf89bb7fe16","modified":1613474446000},{"_id":"themes/freemind/layout/_partial/post/share.ejs","hash":"24c04b319f1b19e887c42db961b90a7e0ab26fdc","modified":1613474446000},{"_id":"themes/freemind/layout/_partial/post/slogan.ejs","hash":"9499f9d781ebe91ac479a7937622832c5a70396d","modified":1613474446000},{"_id":"themes/freemind/layout/_partial/post/tag.ejs","hash":"ca231a24b4d17206991da3468842dd8610d94080","modified":1613474446000},{"_id":"themes/freemind/layout/_partial/post/title.ejs","hash":"10d243104cae400291040cf167a8338da5ad49b4","modified":1613474446000},{"_id":"themes/freemind/source/css/fonts/Fixedsys500c.eot","hash":"49611cf2e4d7e5c489c191f994ba7ac315bcce5c","modified":1613474446000},{"_id":"themes/freemind/source/css/fonts/Fixedsys500c.otf","hash":"e1fede43e072a990b9cd9899cdd26b78b30d305d","modified":1613474446000},{"_id":"themes/freemind/source/css/fonts/Fixedsys500c.ttf","hash":"19a8e49df8611dd0d90133a2eb0e410c23932db4","modified":1613474446000},{"_id":"themes/freemind/source/css/fonts/Fixedsys500c.woff","hash":"21f8e34c5e252a54710c5f6b0e363b9c43f979b2","modified":1613474446000},{"_id":"themes/freemind/source/fonts/google-fonts/0AKsP294HTD-nvJgucYTaIbN6UDyHWBl620a-IRfuBk.woff","hash":"1d9bb14c006d39d7eb0812a85567c7431f899b8d","modified":1613474446000},{"_id":"themes/freemind/source/fonts/google-fonts/0XxGQsSc1g4rdRdjJKZrNBsxEYwM7FgeyaSgU71cLG0.woff","hash":"33225e85c33279e7b4f0c5c65ff93bec740dd59c","modified":1613474446000},{"_id":"themes/freemind/source/fonts/google-fonts/PIPMHY90P7jtyjpXuZ2cLD8E0i7KZn-EPnyo3HZu7kw.woff","hash":"18dc51e642b4df958098d3bbc6d3ba0237ef6150","modified":1613474446000},{"_id":"themes/freemind/source/fonts/google-fonts/LKf8nhXsWg5ybwEGXk8UBQ.woff","hash":"f401d51152681048c06187c5d3919b1407b899c5","modified":1613474446000},{"_id":"themes/freemind/source/fonts/google-fonts/cj2hUnSRBhwmSPr9kS5899kZXW4sYc4BjuAIFc1SXII.woff","hash":"17a484b92c0dacc8e8b4f0d38ccc1db400819d1d","modified":1613474446000},{"_id":"themes/freemind/source/fonts/google-fonts/2UX7WLTfW3W8TclTUvlFyQ.woff","hash":"87deb174af2e2beebb9f09d618a5159ca299a3d0","modified":1613474446000},{"_id":"themes/freemind/source/fonts/google-fonts/UyYrYy3ltEffJV9QueSi4RdbPw3QSf9R-kE0EsQUn2A.woff","hash":"d9f913d09bb3c25749daf8e7ab829c850a842929","modified":1613474446000},{"_id":"themes/freemind/source/fonts/google-fonts/lILlYDvubYemzYzN7GbLkHhCUOGz7vYGh680lGh-uXM.woff","hash":"e6c9f1e5a6a966a8f7250201356f351890a48921","modified":1613474446000},{"_id":"source/_posts/Kubernetes - Deployment/image-20191027105724518.png","hash":"fb74ee1bd4e1f67b57cc66ee192d71b0b51ba673","modified":1613474446000},{"_id":"source/_posts/Kubernetes - Service/1571731875603.png","hash":"baa562ce45e29fcaffc5cef4a96c48ee6542ee0b","modified":1613474446000},{"_id":"source/_posts/Kubernetes - StatefulSet/image-20191027173733318.png","hash":"7529bd766122a21275a9c6742846eefb747b13e8","modified":1613474446000},{"_id":"source/_posts/Kubernetes - 卷/1571731875603.png","hash":"baa562ce45e29fcaffc5cef4a96c48ee6542ee0b","modified":1613474446000},{"_id":"source/_posts/Kubernetes - 卷/1571736520272.png","hash":"528ce0937b69b27c64502cd0fb24ede3bf2e841a","modified":1613474446000},{"_id":"source/_posts/Kubernetes - 卷/1571738187793.png","hash":"5a3352d90a41cc0b622b89d27180b1f6da583a1b","modified":1613474446000},{"_id":"source/_posts/Kubernetes - 卷/1571746264340.png","hash":"1ab4b8a39cac6535c6d53dd100899a0d7d2e64b4","modified":1613474446000},{"_id":"source/_posts/Kubernetes - 概览/1571541562099.png","hash":"e1a3d85f7391812db40d325e72d60d987314cc39","modified":1613474446000},{"_id":"source/_posts/Kubernetes - 概览/1571542030561.png","hash":"8ce7abc6218779867444f92521863e274b070179","modified":1613474446000},{"_id":"source/_posts/Kubernetes - 访问pod元数据及其它资源/image-20191026101622624.png","hash":"27b791b57f215f405c86f0bb48d55862bebcd91e","modified":1613474446000},{"_id":"source/_posts/Kubernetes - 访问pod元数据及其它资源/image-20191026102038019.png","hash":"a4414514dfe85afad675bcbf8947b30c176968d0","modified":1613474446000},{"_id":"source/_posts/Kubernetes - 访问pod元数据及其它资源/image-20191026112434344.png","hash":"92e93d960a27b3ce4f10b4bf566ec92d6bea5019","modified":1613474446000},{"_id":"source/_posts/如何将插件发布到Maven中央库/image-20200229175945672.png","hash":"94718e8381b10ac9d958b23e19040b33380edc5f","modified":1613474446000},{"_id":"themes/freemind/source/css/bootstrap.css.map","hash":"6925683e03d7cae9dc542bfcca38eccf6f66169c","modified":1613474446000},{"_id":"themes/freemind/source/css/fonts/Fixedsys500c.svg","hash":"5ee7dd37d045bc147d73acc8a4825cf7ad35b4af","modified":1613474446000},{"_id":"source/_posts/Python-日志/image-20200307190901858.png","hash":"0a16e244dbe3b3c70e068108c6dc0e9158ff515e","modified":1613474446000},{"_id":"source/_posts/域名解析DNS/image-20191201154145355.png","hash":"97b822e2943c16b860da6b4e33deb6ac3546f31b","modified":1613474446000},{"_id":"source/_posts/用Prometheus和Grafana监控你的服务器/image-20200321224109344.png","hash":"cc923235e8d7a6445832bc525b0385cea797c7b1","modified":1613474446000},{"_id":"themes/freemind/source/fonts/fontawesome-webfont.svg","hash":"cd980eab6db5fa57db670cb2e4278e67e1a4d6c9","modified":1613474446000},{"_id":"source/_posts/如何将插件发布到Maven中央库/image-20200229190243615.png","hash":"2422bfe09092f75d9a8245cdbe68628ead376034","modified":1613474446000},{"_id":"themes/freemind/free386-screenshot.png","hash":"27d84b0b3b178e706d6283231e91327188dab7be","modified":1613474446000},{"_id":"source/_posts/Kubernetes - 概览/1571540922449.png","hash":"a24cc97ab8a6f56172848bc068bc0c25828dbb5c","modified":1613474446000},{"_id":"source/_posts/Kubernetes - 概览/1571540756807.png","hash":"f3dc9c256dd6773a296d1b28226fc0527cec14c5","modified":1613474446000},{"_id":"source/collection/images/1569742465720.png","hash":"f7bafbe8ffebdf76f23f5ef9499e3ec0dc25cf6a","modified":1613474446000},{"_id":"source/.DS_Store","hash":"b48c4f7d61a5928be717d4bd654481ff1eab36ee","modified":1719027226657},{"_id":"source/_posts/demo-post.md","hash":"fd61e893a3b7c246af4c740486fcb3c7317cd788","modified":1719027222685}],"Category":[{"name":"python","_id":"clxpjqcvk0004j6i10gm8w1yy"},{"name":"JOOQ","_id":"clxpjqcvl0009j6i1mxmmvsdd"},{"name":"Vertx","parent":"clxpjqcvl0009j6i1mxmmvsdd","_id":"clxpjqcvn000hj6i1trvzkxig"},{"name":"运维","_id":"clxpjqcvs000oj6i1tb3yzcj2"},{"name":"工具","_id":"clxpjqcwi0019j6i1oqa074su"},{"name":"版本控制","_id":"clxpjqcwj001fj6i18uanlobf"},{"name":"编程语言","_id":"clxpjqcwj001kj6i1i4wwgfpy"},{"name":"容器","_id":"clxpjqcwk001rj6i1uq5r8yl1"},{"name":"Python","_id":"clxpjqcwo002tj6i1pz48w9ew"},{"name":"数据库","_id":"clxpjqcwp0032j6i108seb4d1"},{"name":"Spring","_id":"clxpjqcwr0038j6i1geyvcjur"},{"name":"Vert.x","_id":"clxpjqcxc003yj6i1bhwifu7q"},{"name":"第三方登录","_id":"clxpjqcxf004fj6i1ig8ace2q"},{"name":"网络基础","_id":"clxpjqcxf004mj6i1bwwi31mg"},{"name":"技术巡礼","_id":"clxpjqcxg004uj6i1jmjwoyw1"},{"name":"Webflow","parent":"clxpjqcwr0038j6i1geyvcjur","_id":"clxpjqcxg0050j6i1p32gh1ox"},{"name":"打包编译","_id":"clxpjqcxg0053j6i157n5asb0"},{"name":"随笔","_id":"clxpjqcxg0058j6i1fqlhmngl"},{"name":"后端","_id":"clxpjqcxh0065j6i10jw540zw"},{"name":"算法","_id":"clxpjqcxh006ij6i1bzwynk96"},{"name":"响应式","_id":"clxpjqcxi006wj6i1x3ubedqv"},{"name":"推荐系统","parent":"clxpjqcxh006ij6i1bzwynk96","_id":"clxpjqcxi0077j6i1z931yo3p"}],"Data":[],"Page":[{"title":"分类","date":"2019-09-06T11:09:55.000Z","layout":"categories","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2019-09-06 19:09:55\nlayout: categories\ntype: categories\ncomments: false\n---\n","updated":"2021-02-16T11:20:46.000Z","path":"categories/index.html","_id":"clxpjqcvj0002j6i1n06o5ten","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"标签","date":"2019-09-06T11:09:33.000Z","layout":"tags","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2019-09-06 19:09:33\nlayout: tags\ntype: tags\ncomments: false\n---\n","updated":"2021-02-16T11:20:46.000Z","path":"tags/index.html","_id":"clxpjqcwi0017j6i11rr9b4z8","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"关于","date":"2019-09-07T03:35:10.000Z","comments":0,"_content":"# 关于这里\n2015年, 我是硬件狗, 一直想要写点什么, 开始接触博客, 试着写了一两篇, 没什么感觉, 于是放弃\n\n\n2016年, 还是硬件狗, 开始自学软件, 断断续续在CSDN上更新自己的学习笔记\n\n\n2017年, 程序猿变身中, 一整年没写过一片博客, 忙于应付各种琐碎和心理斗争\n\n\n2018年, 程序猿变身完成, 再次开始断断续续更新博客, 尽管质量不高, 但一篇1.8W访问量的日志让我为之振奋, 有一丢丢成就感\n\n\n2019年, 有了博客，感觉自己在互联网买了房，拥有自己一片天。\n> \\# 更新于2019-10-26\n\n# 干过啥\n- 花两年时间尝试了硬件狗的滋味, 发现并不喜欢\n- 一年半外包公司后端程序员, 对码农一词有了深切而痛心的体会。\n\n# 在干啥\n- 努力工作, 坚持学习, 认真生活\n- Golang, Java, Kotlin, Python\n\n# 关于我\n叫我: 果冻\n代号: gd; zou8944\nEmail: zou894475@gmail.com\n微信: zou894475\n<img src=\"/img/mycard.jpg\" width = \"200\" height = \"200\" alt=\"图片名称\" align=\"center\">\n","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2019-09-07 11:35:10\ncomments: false\n---\n# 关于这里\n2015年, 我是硬件狗, 一直想要写点什么, 开始接触博客, 试着写了一两篇, 没什么感觉, 于是放弃\n\n\n2016年, 还是硬件狗, 开始自学软件, 断断续续在CSDN上更新自己的学习笔记\n\n\n2017年, 程序猿变身中, 一整年没写过一片博客, 忙于应付各种琐碎和心理斗争\n\n\n2018年, 程序猿变身完成, 再次开始断断续续更新博客, 尽管质量不高, 但一篇1.8W访问量的日志让我为之振奋, 有一丢丢成就感\n\n\n2019年, 有了博客，感觉自己在互联网买了房，拥有自己一片天。\n> \\# 更新于2019-10-26\n\n# 干过啥\n- 花两年时间尝试了硬件狗的滋味, 发现并不喜欢\n- 一年半外包公司后端程序员, 对码农一词有了深切而痛心的体会。\n\n# 在干啥\n- 努力工作, 坚持学习, 认真生活\n- Golang, Java, Kotlin, Python\n\n# 关于我\n叫我: 果冻\n代号: gd; zou8944\nEmail: zou894475@gmail.com\n微信: zou894475\n<img src=\"/img/mycard.jpg\" width = \"200\" height = \"200\" alt=\"图片名称\" align=\"center\">\n","updated":"2024-06-22T07:09:41.134Z","path":"about/index.html","_id":"clxpjqcwi001bj6i1d61e9esz","layout":"page","content":"<h1 id=\"关于这里\"><a href=\"#关于这里\" class=\"headerlink\" title=\"关于这里\"></a>关于这里</h1><p>2015年, 我是硬件狗, 一直想要写点什么, 开始接触博客, 试着写了一两篇, 没什么感觉, 于是放弃</p>\n<p>2016年, 还是硬件狗, 开始自学软件, 断断续续在CSDN上更新自己的学习笔记</p>\n<p>2017年, 程序猿变身中, 一整年没写过一片博客, 忙于应付各种琐碎和心理斗争</p>\n<p>2018年, 程序猿变身完成, 再次开始断断续续更新博客, 尽管质量不高, 但一篇1.8W访问量的日志让我为之振奋, 有一丢丢成就感</p>\n<p>2019年, 有了博客，感觉自己在互联网买了房，拥有自己一片天。</p>\n<blockquote>\n<p># 更新于2019-10-26</p>\n</blockquote>\n<h1 id=\"干过啥\"><a href=\"#干过啥\" class=\"headerlink\" title=\"干过啥\"></a>干过啥</h1><ul>\n<li>花两年时间尝试了硬件狗的滋味, 发现并不喜欢</li>\n<li>一年半外包公司后端程序员, 对码农一词有了深切而痛心的体会。</li>\n</ul>\n<h1 id=\"在干啥\"><a href=\"#在干啥\" class=\"headerlink\" title=\"在干啥\"></a>在干啥</h1><ul>\n<li>努力工作, 坚持学习, 认真生活</li>\n<li>Golang, Java, Kotlin, Python</li>\n</ul>\n<h1 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h1><p>叫我: 果冻<br>代号: gd; zou8944<br>Email: <a href=\"mailto:zou894475@gmail.com\" target=\"_blank\" rel=\"noopener\">zou894475@gmail.com</a><br>微信: zou894475<br><img src=\"/img/mycard.jpg\" width=\"200\" height=\"200\" alt=\"图片名称\" align=\"center\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"关于这里\"><a href=\"#关于这里\" class=\"headerlink\" title=\"关于这里\"></a>关于这里</h1><p>2015年, 我是硬件狗, 一直想要写点什么, 开始接触博客, 试着写了一两篇, 没什么感觉, 于是放弃</p>\n<p>2016年, 还是硬件狗, 开始自学软件, 断断续续在CSDN上更新自己的学习笔记</p>\n<p>2017年, 程序猿变身中, 一整年没写过一片博客, 忙于应付各种琐碎和心理斗争</p>\n<p>2018年, 程序猿变身完成, 再次开始断断续续更新博客, 尽管质量不高, 但一篇1.8W访问量的日志让我为之振奋, 有一丢丢成就感</p>\n<p>2019年, 有了博客，感觉自己在互联网买了房，拥有自己一片天。</p>\n<blockquote>\n<p># 更新于2019-10-26</p>\n</blockquote>\n<h1 id=\"干过啥\"><a href=\"#干过啥\" class=\"headerlink\" title=\"干过啥\"></a>干过啥</h1><ul>\n<li>花两年时间尝试了硬件狗的滋味, 发现并不喜欢</li>\n<li>一年半外包公司后端程序员, 对码农一词有了深切而痛心的体会。</li>\n</ul>\n<h1 id=\"在干啥\"><a href=\"#在干啥\" class=\"headerlink\" title=\"在干啥\"></a>在干啥</h1><ul>\n<li>努力工作, 坚持学习, 认真生活</li>\n<li>Golang, Java, Kotlin, Python</li>\n</ul>\n<h1 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h1><p>叫我: 果冻<br>代号: gd; zou8944<br>Email: <a href=\"mailto:zou894475@gmail.com\" target=\"_blank\" rel=\"noopener\">zou894475@gmail.com</a><br>微信: zou894475<br><img src=\"/img/mycard.jpg\" width=\"200\" height=\"200\" alt=\"图片名称\" align=\"center\"></p>\n"}],"Post":[{"title":"示例文章（正式发布时删掉我）","abbrlink":13799,"date":"2020-02-27T13:58:08.000Z","_content":"\n# 引子\n\n这是一个晴朗的午后，我沐浴着窗口洒落的阳光，懒洋洋地敲着代码，喝着并不存在的咖啡，听着窗外并不存在的熙熙攘攘。这是一个疫情中的午后，深圳二月份的天气算是比较厚道，一件薄外套已经让我微微出汗。我，又遇到bug了，调了一上午的bug，自己写的bug，查了半天的bug，甚至让我分不清此刻的汗水是气温还是bug导致的。\n\n随着时间的流逝，bug终究会解决，我们要做的，就是静静地等着。不知不觉已经到了晚上，果然，bug解决了。往往一个bug的持续时间决定了它是否值得被记录。解决完这个bug时，我惊喜地意识到又可以水一篇博文了。呵呵。\n\n<!-- more -->\n\n在Vert.x中，Future是遵循Promise/Future原则的接口，是一个占位符。按官方说的，它代表了一个可能已经发生、或可能还没发生的动作的结果，即一个异步结果。读取其中的结果，通常是设置一个回调方法，但是注意，**一个future只能设置一个回调方法，即一个Handler，或者更具体地说，如果设置多个Handler，则只有最后一个Handler有效。**\n\n```kotlin\nval future = Promise.promise<String>().future();\nfuture.setHandler { ar -> \n    if(ar.failed()){\n        // 处理失败的情况\n    } else {\n        // 处理成功的情况\n    }\n}\n```\n\n# 事故回放\n\n## 使用场景\n\n有一缓存需求：将一段读取数据库的代码的结果缓存起来，缓存有效期十分钟，过期后自动刷新，要求整个过程全异步。\n\n为了后期能够随时更换缓存实现，于是抽闲出如下缓存接口\n\n```kotlin\ninterface Cache<K, V> {\n\n    // get方法，第一个参数为key，第二个参数为缓存过期时获取新的缓存的方法\n  fun get(key: K, mappingFunction: () -> Future<V>): Future<V>\n\n  // 删除缓存值\n  fun invalidate(key: K)\n}\n```\n\n并使用Caffeine实现上述接口\n\n```kotlin\nclass CaffeineProxy<K, V>  : Cache<K, V> {\n\n  private val cache: Cache<K, Future<V>> = Caffeine.newBuilder().build()\n\n  override fun get(key: K, mappingFunction: () -> Future<V>): Future<V> = \n    cache.get(key) { mappingFunction.invoke() }\n\n  override fun invalidate(key: K) = cache.invalidate(key!!)\n\n}\n```\n\n在**协程上下文**中使用，如下\n\n```kotlin\nclass ServiceImpl {\n    \n    private val locationCache = LocationCache()\n    \n    // 由于只缓存一段代码的执行结果，因此只有一个key，用一个内部类将缓存包裹起来\n    inner class LocationCache {\n    // 创建缓存实例\n    private val innerCache = CaffeineProxy<String, List<Location>>()\n    // 取值方法，取的结果是Future实例\n    override suspend fun getCache(): Future<List<JsonObject>> = innerCache.get(\"UniqueCache\") {\n        val promise = Promise.promise<List<JsonObject>>()\n\t\tadminDao.getAvailableLocations(promise)\n        promise.future()\n    }\n  }\n    \n  // 在方法1中使用该缓存\n  suspend fun fun1() {\n      val result = locationCache.getCache().await()\n      . . .  后续操作 . . .\n  }\n    \n  // 在方法2中使用该缓存\n  suspend fun fun2() {\n      val result = locationCache.getCache().await()\n      . . .  后续操作 . . .\n  }\n}\n```\n\n## 问题复现\n\n并发较高的场景下，会出现部分方法调用无响应的情况。上述缓存方法放在Web代码中，对应的就是多个会用到缓存的请求同时发起时，部分请求会永远无响应，或者触发系统的超时机制。\n\n## 原因分析\n\n上述缓存有一个大前提，即将Future缓存起来，并在之后的流通中反复使用同一个被缓存的Future。前文中，我们在协程上下文中调用了Future的await()方法，该方法定义如下。\n\n```kotlin\n/**\n * Awaits the completion of a future without blocking the event loop.\n */\nsuspend fun <T> Future<T>.await(): T = when {\n  succeeded() -> result()\n  failed() -> throw cause()\n  else -> suspendCancellableCoroutine { cont: CancellableContinuation<T> ->\n    setHandler { asyncResult ->\n      if (asyncResult.succeeded()) cont.resume(asyncResult.result() as T)\n      else cont.resumeWithException(asyncResult.cause())\n    }\n  }\n}\n```\n\n可以看到，其逻辑是：如果成功则返回结果；如果失败则抛出异常；Future未完成则调用setHandler()设置回调方法。\n\n再来看看Future的实现FutureImpl的定义\n\n```java\nclass FutureImpl<T> implements Promise<T>, Future<T> {\n\n  private boolean failed;\n  private boolean succeeded;\n  private Handler<AsyncResult<T>> handler;\n  private T result;\n  private Throwable throwable;\n    \n    . . . . . .\n  /**\n   * Set a handler for the result. It will get called when it's complete\n   */\n  public Future<T> setHandler(Handler<AsyncResult<T>> handler) {\n    boolean callHandler;\n    synchronized (this) {\n      callHandler = isComplete();\n      if (!callHandler) {\n        this.handler = handler;\n      }\n    }\n    if (callHandler) {\n      handler.handle(this);\n    }\n    return this;\n  }\n    . . . . . .\n}\n```\n\n可以看到，setHandler()会将传入的handler直接覆盖掉现有的handler属性。\n\n于是可以分析出正常情景和异常情景如下\n\n- 异常情景\n\n  缓存已过期，此时方法1调用获取缓存方法，拿到Future，该Future未完成，于是通过await()方法调用setHandler()设置了一个回调方法；在缓存中的Future尚未完成前，方法2也调用获取缓存方法，得到同一个Future实例，同样，由于它未完成，于是通过await()方法再次调用setHandler()设置了新的回调方法。\n\n  这样，方法2设置的回调方法覆盖了方法1设置的回调，当Future完成时，方法2的回调方法将得到通知，使得方法2能够正常继续执行；方法1的回调则会永远等待被回调，直到超时。\n\n- 正常情景\n\n  缓存有效，且Future已完成，根据await()方法的定义：先同步地读取Future的结果，在本场景中，一直能够读取到Future结果，而不会进入到setHandler()，这样无论并发多高，都能够正确返回结果。\n\n如果缓存时间设置很长，Future从创建到完成的时间很短，在单元测试阶段甚至SIT都很难发现。很容易造成线上偶现的bug，并且相当地隐晦，可以说是非常难以发现了。\n\n## 然后呢？\n\n到这里，原因找到了。但是仔细想想，从语义上，Future代表一个异步执行的结果，常规的使用方法是setHandler()设置回调方法，那一个结果被多处使用似乎是很自然的需求，Vert.x设置这样一个限制，是不是有些反直觉，或者反人类呢？\n\n或许我们可以在这个[issue](https://github.com/eclipse-vertx/vert.x/issues/1920)找到些许解释。简而言之，Future就这样了，如果需要一次生成多次使用，请考虑其它库来实现这样的效果，如RxJava。或者等Vert.x4中将会有类似功能的实现。\n\n我想吐槽的点在于，目前Vert.x的Future实现不修改没有问题，但做一些针对上述问题的防护措施也是可以的，可是并没有。\n\n# 正确的做法\n\n看来，Future是不能使用了，那我们应该使用什么呢？官方推荐使用RxJava，查看[文档](http://reactivex.io/documentation/subject.html)后，发现有如下几个占位符可选。\n\n- Single — Single.cache()生成的Single，可被多次订阅\n- 订阅Single的BehaviorSubject —— 可订阅和被订阅，用它订阅Single，我们再订阅它。特性上，它返回其订阅的最近的消息，并永远不会主动结束，即可被多次订阅\n\n二者综合选其一，肯定是能直接使用Single就直接使用Single就好呀。\n\n于是将我们的缓存实现修改成缓存Single的形式\n\n```kotlin\n/** \n * Cache接口\n */\ninterface Cache<K, V> {\n\n    // get方法，第一个参数为key，第二个参数为缓存过期时获取新的缓存的方法\n  fun get(key: K, mappingFunction: () -> Single<V>): Single<V>\n  . . . . . .\n}\n\n/** \n * Cache实现\n */\nclass CaffeineProxy<K, V>  : Cache<K, V> {\n\n  private val cache: Cache<K, Single<V>> = Caffeine.newBuilder().build()\n\n  override fun get(key: K, mappingFunction: () -> Single<V>): Single<V> = \n    cache.get(key) { mappingFunction.invoke() }\n  . . . . . .\n}\n```\n\n使用时获取Single并订阅即可。\n\n```kotlin\nclass ServiceImpl {\n    . . . . . .\n    suspend fun fun1() {\n        locationCache.getCache().subscribe({ result ->\n        // 对成功的处理\n        },{ cause ->\n            // 对失败的处理\n        })\n    }\n    . . . . . .\n}\n```\n\n# 合适的做法\n\n使用Single虽然实现了异步缓存的功能，但在协程中使用RxJava却是浪费了协程的特性。那如果我们在调用时想要使用Future呢。为此可以将缓存包装一下，同时暴露协程、Future、Single三种API风格的接口，任君选择。\n\n接口如下\n\n```kotlin\ninterface CacheProxy<K, V> {\n\n  // Single API\n  fun singleGet(key: K, mappingFunction: () -> Single<V>): Single<V>\n  \n  // Future API \n  fun futureGet(key: K, mappingFunction: () -> Future<V>): Future<V>\n\n  // 协程API\n  suspend fun coroutineGet(key: K, mappingFunction: suspend () -> V): V\n\n}\n```\n\n实现类可以这么做。\n\n```kotlin\nclass CaffeineProxy<K, V>(val vertx: Vertx) : CacheProxy<K, V> {\n\n  private val cache: Cache<K, Single<V>> = Caffeine.newBuilder().build()\n\n  // 接收返回Single的方法，返回一个Single\n  override fun singleGet(key: K, mappingFunction: () -> Single<V>): Single<V> {\n    return cache.get(key!!) { mappingFunction.invoke() }!!\n  }\n\n  // 接收返回Future的方法，返回一个Future\n  override fun futureGet(key: K, mappingFunction: () -> Future<V>): Future<V> {\n    val promise = Promise.promise<V>()\n    cache.get(key) { SingleHelper.toSingle<V> { mappingFunction.invoke().setHandler(it) }.cache() }!!.subscribe({\n      promise.complete(it)\n    }, {\n      promise.fail(it)\n    })\n    return promise.future()\n  }\n\n  // 接收suspend方法，返回一个值\n  override suspend fun coroutineGet(key: K, mappingFunction: suspend () -> V) = withContext(vertx.dispatcher()) {\n    val promise = Promise.promise<V>()\n    cache.get(key) {\n      Single.create<V> {\n        launch {\n          try {\n            it.onSuccess(mappingFunction.invoke())\n          } catch (e: Exception) {\n            it.onError(e)\n          }\n        }\n      }.cache()\n    }!!.subscribe({\n      promise.complete(it)\n    }, {\n      promise.fail(it)\n    })\n    promise.future().await()\n  }!!\n}\n```\n\nRx风格的接口不必多说，直来直去；\n\nFuture风格的接口，使用了Vert.x提供的API在Single和Future之间进行了切换；协程会稍微麻烦点：\n\n协程内部可以看做是同步执行的，在获取Single时，为了全异步特性，我们需要异步执行，因此使用launch启动新协程是个好办法。\n\n至此，我们的缓存接口能够适用于目前所有三种异步API，使用时无缝衔接。\n\n# 总结\n\nFuture多次使用的问题，并不是我第一次遇到，只不过上次主要是靠前辈解决，以至于过了太久我都没什么印象，说来确实不太应该。\n\n但好在问题解决了，同时也提出了一种通用的调用方法，在实用层面上，是值得参考的。\n\n# 参考文档\n\n1. [Vert.x官方手册 - 核心部分](https://vertx.io/docs/vertx-core/java/)\n\n2. [exlipse-vertx/vert.x - issue#1920](https://github.com/eclipse-vertx/vert.x/issues/1920)\n3. [Reactivex Java - Single](http://reactivex.io/documentation/single.html)\n4. [Reactivex Java - Subject](http://reactivex.io/documentation/subject.html)","source":"_posts/demo-post.md","raw":"---\ntitle: 示例文章（正式发布时删掉我）\ntags:\n  - Vert.x\ncategories:\n  - Vert.x\nabbrlink: 13799\ndate: 2020-02-27 21:58:08\n---\n\n# 引子\n\n这是一个晴朗的午后，我沐浴着窗口洒落的阳光，懒洋洋地敲着代码，喝着并不存在的咖啡，听着窗外并不存在的熙熙攘攘。这是一个疫情中的午后，深圳二月份的天气算是比较厚道，一件薄外套已经让我微微出汗。我，又遇到bug了，调了一上午的bug，自己写的bug，查了半天的bug，甚至让我分不清此刻的汗水是气温还是bug导致的。\n\n随着时间的流逝，bug终究会解决，我们要做的，就是静静地等着。不知不觉已经到了晚上，果然，bug解决了。往往一个bug的持续时间决定了它是否值得被记录。解决完这个bug时，我惊喜地意识到又可以水一篇博文了。呵呵。\n\n<!-- more -->\n\n在Vert.x中，Future是遵循Promise/Future原则的接口，是一个占位符。按官方说的，它代表了一个可能已经发生、或可能还没发生的动作的结果，即一个异步结果。读取其中的结果，通常是设置一个回调方法，但是注意，**一个future只能设置一个回调方法，即一个Handler，或者更具体地说，如果设置多个Handler，则只有最后一个Handler有效。**\n\n```kotlin\nval future = Promise.promise<String>().future();\nfuture.setHandler { ar -> \n    if(ar.failed()){\n        // 处理失败的情况\n    } else {\n        // 处理成功的情况\n    }\n}\n```\n\n# 事故回放\n\n## 使用场景\n\n有一缓存需求：将一段读取数据库的代码的结果缓存起来，缓存有效期十分钟，过期后自动刷新，要求整个过程全异步。\n\n为了后期能够随时更换缓存实现，于是抽闲出如下缓存接口\n\n```kotlin\ninterface Cache<K, V> {\n\n    // get方法，第一个参数为key，第二个参数为缓存过期时获取新的缓存的方法\n  fun get(key: K, mappingFunction: () -> Future<V>): Future<V>\n\n  // 删除缓存值\n  fun invalidate(key: K)\n}\n```\n\n并使用Caffeine实现上述接口\n\n```kotlin\nclass CaffeineProxy<K, V>  : Cache<K, V> {\n\n  private val cache: Cache<K, Future<V>> = Caffeine.newBuilder().build()\n\n  override fun get(key: K, mappingFunction: () -> Future<V>): Future<V> = \n    cache.get(key) { mappingFunction.invoke() }\n\n  override fun invalidate(key: K) = cache.invalidate(key!!)\n\n}\n```\n\n在**协程上下文**中使用，如下\n\n```kotlin\nclass ServiceImpl {\n    \n    private val locationCache = LocationCache()\n    \n    // 由于只缓存一段代码的执行结果，因此只有一个key，用一个内部类将缓存包裹起来\n    inner class LocationCache {\n    // 创建缓存实例\n    private val innerCache = CaffeineProxy<String, List<Location>>()\n    // 取值方法，取的结果是Future实例\n    override suspend fun getCache(): Future<List<JsonObject>> = innerCache.get(\"UniqueCache\") {\n        val promise = Promise.promise<List<JsonObject>>()\n\t\tadminDao.getAvailableLocations(promise)\n        promise.future()\n    }\n  }\n    \n  // 在方法1中使用该缓存\n  suspend fun fun1() {\n      val result = locationCache.getCache().await()\n      . . .  后续操作 . . .\n  }\n    \n  // 在方法2中使用该缓存\n  suspend fun fun2() {\n      val result = locationCache.getCache().await()\n      . . .  后续操作 . . .\n  }\n}\n```\n\n## 问题复现\n\n并发较高的场景下，会出现部分方法调用无响应的情况。上述缓存方法放在Web代码中，对应的就是多个会用到缓存的请求同时发起时，部分请求会永远无响应，或者触发系统的超时机制。\n\n## 原因分析\n\n上述缓存有一个大前提，即将Future缓存起来，并在之后的流通中反复使用同一个被缓存的Future。前文中，我们在协程上下文中调用了Future的await()方法，该方法定义如下。\n\n```kotlin\n/**\n * Awaits the completion of a future without blocking the event loop.\n */\nsuspend fun <T> Future<T>.await(): T = when {\n  succeeded() -> result()\n  failed() -> throw cause()\n  else -> suspendCancellableCoroutine { cont: CancellableContinuation<T> ->\n    setHandler { asyncResult ->\n      if (asyncResult.succeeded()) cont.resume(asyncResult.result() as T)\n      else cont.resumeWithException(asyncResult.cause())\n    }\n  }\n}\n```\n\n可以看到，其逻辑是：如果成功则返回结果；如果失败则抛出异常；Future未完成则调用setHandler()设置回调方法。\n\n再来看看Future的实现FutureImpl的定义\n\n```java\nclass FutureImpl<T> implements Promise<T>, Future<T> {\n\n  private boolean failed;\n  private boolean succeeded;\n  private Handler<AsyncResult<T>> handler;\n  private T result;\n  private Throwable throwable;\n    \n    . . . . . .\n  /**\n   * Set a handler for the result. It will get called when it's complete\n   */\n  public Future<T> setHandler(Handler<AsyncResult<T>> handler) {\n    boolean callHandler;\n    synchronized (this) {\n      callHandler = isComplete();\n      if (!callHandler) {\n        this.handler = handler;\n      }\n    }\n    if (callHandler) {\n      handler.handle(this);\n    }\n    return this;\n  }\n    . . . . . .\n}\n```\n\n可以看到，setHandler()会将传入的handler直接覆盖掉现有的handler属性。\n\n于是可以分析出正常情景和异常情景如下\n\n- 异常情景\n\n  缓存已过期，此时方法1调用获取缓存方法，拿到Future，该Future未完成，于是通过await()方法调用setHandler()设置了一个回调方法；在缓存中的Future尚未完成前，方法2也调用获取缓存方法，得到同一个Future实例，同样，由于它未完成，于是通过await()方法再次调用setHandler()设置了新的回调方法。\n\n  这样，方法2设置的回调方法覆盖了方法1设置的回调，当Future完成时，方法2的回调方法将得到通知，使得方法2能够正常继续执行；方法1的回调则会永远等待被回调，直到超时。\n\n- 正常情景\n\n  缓存有效，且Future已完成，根据await()方法的定义：先同步地读取Future的结果，在本场景中，一直能够读取到Future结果，而不会进入到setHandler()，这样无论并发多高，都能够正确返回结果。\n\n如果缓存时间设置很长，Future从创建到完成的时间很短，在单元测试阶段甚至SIT都很难发现。很容易造成线上偶现的bug，并且相当地隐晦，可以说是非常难以发现了。\n\n## 然后呢？\n\n到这里，原因找到了。但是仔细想想，从语义上，Future代表一个异步执行的结果，常规的使用方法是setHandler()设置回调方法，那一个结果被多处使用似乎是很自然的需求，Vert.x设置这样一个限制，是不是有些反直觉，或者反人类呢？\n\n或许我们可以在这个[issue](https://github.com/eclipse-vertx/vert.x/issues/1920)找到些许解释。简而言之，Future就这样了，如果需要一次生成多次使用，请考虑其它库来实现这样的效果，如RxJava。或者等Vert.x4中将会有类似功能的实现。\n\n我想吐槽的点在于，目前Vert.x的Future实现不修改没有问题，但做一些针对上述问题的防护措施也是可以的，可是并没有。\n\n# 正确的做法\n\n看来，Future是不能使用了，那我们应该使用什么呢？官方推荐使用RxJava，查看[文档](http://reactivex.io/documentation/subject.html)后，发现有如下几个占位符可选。\n\n- Single — Single.cache()生成的Single，可被多次订阅\n- 订阅Single的BehaviorSubject —— 可订阅和被订阅，用它订阅Single，我们再订阅它。特性上，它返回其订阅的最近的消息，并永远不会主动结束，即可被多次订阅\n\n二者综合选其一，肯定是能直接使用Single就直接使用Single就好呀。\n\n于是将我们的缓存实现修改成缓存Single的形式\n\n```kotlin\n/** \n * Cache接口\n */\ninterface Cache<K, V> {\n\n    // get方法，第一个参数为key，第二个参数为缓存过期时获取新的缓存的方法\n  fun get(key: K, mappingFunction: () -> Single<V>): Single<V>\n  . . . . . .\n}\n\n/** \n * Cache实现\n */\nclass CaffeineProxy<K, V>  : Cache<K, V> {\n\n  private val cache: Cache<K, Single<V>> = Caffeine.newBuilder().build()\n\n  override fun get(key: K, mappingFunction: () -> Single<V>): Single<V> = \n    cache.get(key) { mappingFunction.invoke() }\n  . . . . . .\n}\n```\n\n使用时获取Single并订阅即可。\n\n```kotlin\nclass ServiceImpl {\n    . . . . . .\n    suspend fun fun1() {\n        locationCache.getCache().subscribe({ result ->\n        // 对成功的处理\n        },{ cause ->\n            // 对失败的处理\n        })\n    }\n    . . . . . .\n}\n```\n\n# 合适的做法\n\n使用Single虽然实现了异步缓存的功能，但在协程中使用RxJava却是浪费了协程的特性。那如果我们在调用时想要使用Future呢。为此可以将缓存包装一下，同时暴露协程、Future、Single三种API风格的接口，任君选择。\n\n接口如下\n\n```kotlin\ninterface CacheProxy<K, V> {\n\n  // Single API\n  fun singleGet(key: K, mappingFunction: () -> Single<V>): Single<V>\n  \n  // Future API \n  fun futureGet(key: K, mappingFunction: () -> Future<V>): Future<V>\n\n  // 协程API\n  suspend fun coroutineGet(key: K, mappingFunction: suspend () -> V): V\n\n}\n```\n\n实现类可以这么做。\n\n```kotlin\nclass CaffeineProxy<K, V>(val vertx: Vertx) : CacheProxy<K, V> {\n\n  private val cache: Cache<K, Single<V>> = Caffeine.newBuilder().build()\n\n  // 接收返回Single的方法，返回一个Single\n  override fun singleGet(key: K, mappingFunction: () -> Single<V>): Single<V> {\n    return cache.get(key!!) { mappingFunction.invoke() }!!\n  }\n\n  // 接收返回Future的方法，返回一个Future\n  override fun futureGet(key: K, mappingFunction: () -> Future<V>): Future<V> {\n    val promise = Promise.promise<V>()\n    cache.get(key) { SingleHelper.toSingle<V> { mappingFunction.invoke().setHandler(it) }.cache() }!!.subscribe({\n      promise.complete(it)\n    }, {\n      promise.fail(it)\n    })\n    return promise.future()\n  }\n\n  // 接收suspend方法，返回一个值\n  override suspend fun coroutineGet(key: K, mappingFunction: suspend () -> V) = withContext(vertx.dispatcher()) {\n    val promise = Promise.promise<V>()\n    cache.get(key) {\n      Single.create<V> {\n        launch {\n          try {\n            it.onSuccess(mappingFunction.invoke())\n          } catch (e: Exception) {\n            it.onError(e)\n          }\n        }\n      }.cache()\n    }!!.subscribe({\n      promise.complete(it)\n    }, {\n      promise.fail(it)\n    })\n    promise.future().await()\n  }!!\n}\n```\n\nRx风格的接口不必多说，直来直去；\n\nFuture风格的接口，使用了Vert.x提供的API在Single和Future之间进行了切换；协程会稍微麻烦点：\n\n协程内部可以看做是同步执行的，在获取Single时，为了全异步特性，我们需要异步执行，因此使用launch启动新协程是个好办法。\n\n至此，我们的缓存接口能够适用于目前所有三种异步API，使用时无缝衔接。\n\n# 总结\n\nFuture多次使用的问题，并不是我第一次遇到，只不过上次主要是靠前辈解决，以至于过了太久我都没什么印象，说来确实不太应该。\n\n但好在问题解决了，同时也提出了一种通用的调用方法，在实用层面上，是值得参考的。\n\n# 参考文档\n\n1. [Vert.x官方手册 - 核心部分](https://vertx.io/docs/vertx-core/java/)\n\n2. [exlipse-vertx/vert.x - issue#1920](https://github.com/eclipse-vertx/vert.x/issues/1920)\n3. [Reactivex Java - Single](http://reactivex.io/documentation/single.html)\n4. [Reactivex Java - Subject](http://reactivex.io/documentation/subject.html)","slug":"demo-post","published":1,"updated":"2024-06-22T03:33:42.685Z","_id":"clxpkfzye008mnwi1hh7v0r27","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"引子\"><a href=\"#引子\" class=\"headerlink\" title=\"引子\"></a>引子</h1><p>这是一个晴朗的午后，我沐浴着窗口洒落的阳光，懒洋洋地敲着代码，喝着并不存在的咖啡，听着窗外并不存在的熙熙攘攘。这是一个疫情中的午后，深圳二月份的天气算是比较厚道，一件薄外套已经让我微微出汗。我，又遇到bug了，调了一上午的bug，自己写的bug，查了半天的bug，甚至让我分不清此刻的汗水是气温还是bug导致的。</p>\n<p>随着时间的流逝，bug终究会解决，我们要做的，就是静静地等着。不知不觉已经到了晚上，果然，bug解决了。往往一个bug的持续时间决定了它是否值得被记录。解决完这个bug时，我惊喜地意识到又可以水一篇博文了。呵呵。</p>\n<a id=\"more\"></a>\n\n<p>在Vert.x中，Future是遵循Promise/Future原则的接口，是一个占位符。按官方说的，它代表了一个可能已经发生、或可能还没发生的动作的结果，即一个异步结果。读取其中的结果，通常是设置一个回调方法，但是注意，<strong>一个future只能设置一个回调方法，即一个Handler，或者更具体地说，如果设置多个Handler，则只有最后一个Handler有效。</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> future = Promise.promise&lt;String&gt;().future();</span><br><span class=\"line\">future.setHandler &#123; ar -&gt; </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(ar.failed())&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 处理失败的情况</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 处理成功的情况</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"事故回放\"><a href=\"#事故回放\" class=\"headerlink\" title=\"事故回放\"></a>事故回放</h1><h2 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h2><p>有一缓存需求：将一段读取数据库的代码的结果缓存起来，缓存有效期十分钟，过期后自动刷新，要求整个过程全异步。</p>\n<p>为了后期能够随时更换缓存实现，于是抽闲出如下缓存接口</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Cache</span>&lt;<span class=\"type\">K, V</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// get方法，第一个参数为key，第二个参数为缓存过期时获取新的缓存的方法</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">get</span><span class=\"params\">(key: <span class=\"type\">K</span>, mappingFunction: () -&gt; <span class=\"type\">Future</span>&lt;<span class=\"type\">V</span>&gt;)</span></span>: Future&lt;V&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 删除缓存值</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">invalidate</span><span class=\"params\">(key: <span class=\"type\">K</span>)</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>并使用Caffeine实现上述接口</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CaffeineProxy</span>&lt;<span class=\"type\">K, V</span>&gt;  : <span class=\"type\">Cache</span>&lt;<span class=\"type\">K, V</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> cache: Cache&lt;K, Future&lt;V&gt;&gt; = Caffeine.newBuilder().build()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">get</span><span class=\"params\">(key: <span class=\"type\">K</span>, mappingFunction: () -&gt; <span class=\"type\">Future</span>&lt;<span class=\"type\">V</span>&gt;)</span></span>: Future&lt;V&gt; = </span><br><span class=\"line\">    cache.<span class=\"keyword\">get</span>(key) &#123; mappingFunction.invoke() &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">invalidate</span><span class=\"params\">(key: <span class=\"type\">K</span>)</span></span> = cache.invalidate(key!!)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在<strong>协程上下文</strong>中使用，如下</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ServiceImpl</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> locationCache = LocationCache()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 由于只缓存一段代码的执行结果，因此只有一个key，用一个内部类将缓存包裹起来</span></span><br><span class=\"line\">    <span class=\"keyword\">inner</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LocationCache</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建缓存实例</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> innerCache = CaffeineProxy&lt;String, List&lt;Location&gt;&gt;()</span><br><span class=\"line\">    <span class=\"comment\">// 取值方法，取的结果是Future实例</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getCache</span><span class=\"params\">()</span></span>: Future&lt;List&lt;JsonObject&gt;&gt; = innerCache.<span class=\"keyword\">get</span>(<span class=\"string\">\"UniqueCache\"</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> promise = Promise.promise&lt;List&lt;JsonObject&gt;&gt;()</span><br><span class=\"line\">\t\tadminDao.getAvailableLocations(promise)</span><br><span class=\"line\">        promise.future()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"comment\">// 在方法1中使用该缓存</span></span><br><span class=\"line\">  <span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">fun1</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">val</span> result = locationCache.getCache().await()</span><br><span class=\"line\">      . . .  后续操作 . . .</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"comment\">// 在方法2中使用该缓存</span></span><br><span class=\"line\">  <span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">fun2</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">val</span> result = locationCache.getCache().await()</span><br><span class=\"line\">      . . .  后续操作 . . .</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"问题复现\"><a href=\"#问题复现\" class=\"headerlink\" title=\"问题复现\"></a>问题复现</h2><p>并发较高的场景下，会出现部分方法调用无响应的情况。上述缓存方法放在Web代码中，对应的就是多个会用到缓存的请求同时发起时，部分请求会永远无响应，或者触发系统的超时机制。</p>\n<h2 id=\"原因分析\"><a href=\"#原因分析\" class=\"headerlink\" title=\"原因分析\"></a>原因分析</h2><p>上述缓存有一个大前提，即将Future缓存起来，并在之后的流通中反复使用同一个被缓存的Future。前文中，我们在协程上下文中调用了Future的await()方法，该方法定义如下。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Awaits the completion of a future without blocking the event loop.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> Future<span class=\"type\">&lt;T&gt;</span>.<span class=\"title\">await</span><span class=\"params\">()</span></span>: T = <span class=\"keyword\">when</span> &#123;</span><br><span class=\"line\">  succeeded() -&gt; result()</span><br><span class=\"line\">  failed() -&gt; <span class=\"keyword\">throw</span> cause()</span><br><span class=\"line\">  <span class=\"keyword\">else</span> -&gt; suspendCancellableCoroutine &#123; cont: CancellableContinuation&lt;T&gt; -&gt;</span><br><span class=\"line\">    setHandler &#123; asyncResult -&gt;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (asyncResult.succeeded()) cont.resume(asyncResult.result() <span class=\"keyword\">as</span> T)</span><br><span class=\"line\">      <span class=\"keyword\">else</span> cont.resumeWithException(asyncResult.cause())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，其逻辑是：如果成功则返回结果；如果失败则抛出异常；Future未完成则调用setHandler()设置回调方法。</p>\n<p>再来看看Future的实现FutureImpl的定义</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FutureImpl</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Promise</span>&lt;<span class=\"title\">T</span>&gt;, <span class=\"title\">Future</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> failed;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> succeeded;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Handler&lt;AsyncResult&lt;T&gt;&gt; handler;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> T result;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Throwable throwable;</span><br><span class=\"line\">    </span><br><span class=\"line\">    . . . . . .</span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * Set a handler for the result. It will get called when it's complete</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Future&lt;T&gt; <span class=\"title\">setHandler</span><span class=\"params\">(Handler&lt;AsyncResult&lt;T&gt;&gt; handler)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> callHandler;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">      callHandler = isComplete();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!callHandler) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.handler = handler;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (callHandler) &#123;</span><br><span class=\"line\">      handler.handle(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">    . . . . . .</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，setHandler()会将传入的handler直接覆盖掉现有的handler属性。</p>\n<p>于是可以分析出正常情景和异常情景如下</p>\n<ul>\n<li><p>异常情景</p>\n<p>缓存已过期，此时方法1调用获取缓存方法，拿到Future，该Future未完成，于是通过await()方法调用setHandler()设置了一个回调方法；在缓存中的Future尚未完成前，方法2也调用获取缓存方法，得到同一个Future实例，同样，由于它未完成，于是通过await()方法再次调用setHandler()设置了新的回调方法。</p>\n<p>这样，方法2设置的回调方法覆盖了方法1设置的回调，当Future完成时，方法2的回调方法将得到通知，使得方法2能够正常继续执行；方法1的回调则会永远等待被回调，直到超时。</p>\n</li>\n<li><p>正常情景</p>\n<p>缓存有效，且Future已完成，根据await()方法的定义：先同步地读取Future的结果，在本场景中，一直能够读取到Future结果，而不会进入到setHandler()，这样无论并发多高，都能够正确返回结果。</p>\n</li>\n</ul>\n<p>如果缓存时间设置很长，Future从创建到完成的时间很短，在单元测试阶段甚至SIT都很难发现。很容易造成线上偶现的bug，并且相当地隐晦，可以说是非常难以发现了。</p>\n<h2 id=\"然后呢？\"><a href=\"#然后呢？\" class=\"headerlink\" title=\"然后呢？\"></a>然后呢？</h2><p>到这里，原因找到了。但是仔细想想，从语义上，Future代表一个异步执行的结果，常规的使用方法是setHandler()设置回调方法，那一个结果被多处使用似乎是很自然的需求，Vert.x设置这样一个限制，是不是有些反直觉，或者反人类呢？</p>\n<p>或许我们可以在这个<a href=\"https://github.com/eclipse-vertx/vert.x/issues/1920\" target=\"_blank\" rel=\"noopener\">issue</a>找到些许解释。简而言之，Future就这样了，如果需要一次生成多次使用，请考虑其它库来实现这样的效果，如RxJava。或者等Vert.x4中将会有类似功能的实现。</p>\n<p>我想吐槽的点在于，目前Vert.x的Future实现不修改没有问题，但做一些针对上述问题的防护措施也是可以的，可是并没有。</p>\n<h1 id=\"正确的做法\"><a href=\"#正确的做法\" class=\"headerlink\" title=\"正确的做法\"></a>正确的做法</h1><p>看来，Future是不能使用了，那我们应该使用什么呢？官方推荐使用RxJava，查看<a href=\"http://reactivex.io/documentation/subject.html\" target=\"_blank\" rel=\"noopener\">文档</a>后，发现有如下几个占位符可选。</p>\n<ul>\n<li>Single — Single.cache()生成的Single，可被多次订阅</li>\n<li>订阅Single的BehaviorSubject —— 可订阅和被订阅，用它订阅Single，我们再订阅它。特性上，它返回其订阅的最近的消息，并永远不会主动结束，即可被多次订阅</li>\n</ul>\n<p>二者综合选其一，肯定是能直接使用Single就直接使用Single就好呀。</p>\n<p>于是将我们的缓存实现修改成缓存Single的形式</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> * Cache接口</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Cache</span>&lt;<span class=\"type\">K, V</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// get方法，第一个参数为key，第二个参数为缓存过期时获取新的缓存的方法</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">get</span><span class=\"params\">(key: <span class=\"type\">K</span>, mappingFunction: () -&gt; <span class=\"type\">Single</span>&lt;<span class=\"type\">V</span>&gt;)</span></span>: Single&lt;V&gt;</span><br><span class=\"line\">  . . . . . .</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> * Cache实现</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CaffeineProxy</span>&lt;<span class=\"type\">K, V</span>&gt;  : <span class=\"type\">Cache</span>&lt;<span class=\"type\">K, V</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> cache: Cache&lt;K, Single&lt;V&gt;&gt; = Caffeine.newBuilder().build()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">get</span><span class=\"params\">(key: <span class=\"type\">K</span>, mappingFunction: () -&gt; <span class=\"type\">Single</span>&lt;<span class=\"type\">V</span>&gt;)</span></span>: Single&lt;V&gt; = </span><br><span class=\"line\">    cache.<span class=\"keyword\">get</span>(key) &#123; mappingFunction.invoke() &#125;</span><br><span class=\"line\">  . . . . . .</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用时获取Single并订阅即可。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ServiceImpl</span> </span>&#123;</span><br><span class=\"line\">    . . . . . .</span><br><span class=\"line\">    <span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">fun1</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        locationCache.getCache().subscribe(&#123; result -&gt;</span><br><span class=\"line\">        <span class=\"comment\">// 对成功的处理</span></span><br><span class=\"line\">        &#125;,&#123; cause -&gt;</span><br><span class=\"line\">            <span class=\"comment\">// 对失败的处理</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    . . . . . .</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"合适的做法\"><a href=\"#合适的做法\" class=\"headerlink\" title=\"合适的做法\"></a>合适的做法</h1><p>使用Single虽然实现了异步缓存的功能，但在协程中使用RxJava却是浪费了协程的特性。那如果我们在调用时想要使用Future呢。为此可以将缓存包装一下，同时暴露协程、Future、Single三种API风格的接口，任君选择。</p>\n<p>接口如下</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">CacheProxy</span>&lt;<span class=\"type\">K, V</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Single API</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">singleGet</span><span class=\"params\">(key: <span class=\"type\">K</span>, mappingFunction: () -&gt; <span class=\"type\">Single</span>&lt;<span class=\"type\">V</span>&gt;)</span></span>: Single&lt;V&gt;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// Future API </span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">futureGet</span><span class=\"params\">(key: <span class=\"type\">K</span>, mappingFunction: () -&gt; <span class=\"type\">Future</span>&lt;<span class=\"type\">V</span>&gt;)</span></span>: Future&lt;V&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 协程API</span></span><br><span class=\"line\">  <span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">coroutineGet</span><span class=\"params\">(key: <span class=\"type\">K</span>, mappingFunction: <span class=\"type\">suspend</span> () -&gt; <span class=\"type\">V</span>)</span></span>: V</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实现类可以这么做。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CaffeineProxy</span>&lt;<span class=\"type\">K, V</span>&gt;</span>(<span class=\"keyword\">val</span> vertx: Vertx) : CacheProxy&lt;K, V&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> cache: Cache&lt;K, Single&lt;V&gt;&gt; = Caffeine.newBuilder().build()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 接收返回Single的方法，返回一个Single</span></span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">singleGet</span><span class=\"params\">(key: <span class=\"type\">K</span>, mappingFunction: () -&gt; <span class=\"type\">Single</span>&lt;<span class=\"type\">V</span>&gt;)</span></span>: Single&lt;V&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cache.<span class=\"keyword\">get</span>(key!!) &#123; mappingFunction.invoke() &#125;!!</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 接收返回Future的方法，返回一个Future</span></span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">futureGet</span><span class=\"params\">(key: <span class=\"type\">K</span>, mappingFunction: () -&gt; <span class=\"type\">Future</span>&lt;<span class=\"type\">V</span>&gt;)</span></span>: Future&lt;V&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> promise = Promise.promise&lt;V&gt;()</span><br><span class=\"line\">    cache.<span class=\"keyword\">get</span>(key) &#123; SingleHelper.toSingle&lt;V&gt; &#123; mappingFunction.invoke().setHandler(it) &#125;.cache() &#125;!!.subscribe(&#123;</span><br><span class=\"line\">      promise.complete(it)</span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">      promise.fail(it)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> promise.future()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 接收suspend方法，返回一个值</span></span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">coroutineGet</span><span class=\"params\">(key: <span class=\"type\">K</span>, mappingFunction: <span class=\"type\">suspend</span> () -&gt; <span class=\"type\">V</span>)</span></span> = withContext(vertx.dispatcher()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> promise = Promise.promise&lt;V&gt;()</span><br><span class=\"line\">    cache.<span class=\"keyword\">get</span>(key) &#123;</span><br><span class=\"line\">      Single.create&lt;V&gt; &#123;</span><br><span class=\"line\">        launch &#123;</span><br><span class=\"line\">          <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            it.onSuccess(mappingFunction.invoke())</span><br><span class=\"line\">          &#125; <span class=\"keyword\">catch</span> (e: Exception) &#123;</span><br><span class=\"line\">            it.onError(e)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;.cache()</span><br><span class=\"line\">    &#125;!!.subscribe(&#123;</span><br><span class=\"line\">      promise.complete(it)</span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">      promise.fail(it)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    promise.future().await()</span><br><span class=\"line\">  &#125;!!</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Rx风格的接口不必多说，直来直去；</p>\n<p>Future风格的接口，使用了Vert.x提供的API在Single和Future之间进行了切换；协程会稍微麻烦点：</p>\n<p>协程内部可以看做是同步执行的，在获取Single时，为了全异步特性，我们需要异步执行，因此使用launch启动新协程是个好办法。</p>\n<p>至此，我们的缓存接口能够适用于目前所有三种异步API，使用时无缝衔接。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>Future多次使用的问题，并不是我第一次遇到，只不过上次主要是靠前辈解决，以至于过了太久我都没什么印象，说来确实不太应该。</p>\n<p>但好在问题解决了，同时也提出了一种通用的调用方法，在实用层面上，是值得参考的。</p>\n<h1 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h1><ol>\n<li><p><a href=\"https://vertx.io/docs/vertx-core/java/\" target=\"_blank\" rel=\"noopener\">Vert.x官方手册 - 核心部分</a></p>\n</li>\n<li><p><a href=\"https://github.com/eclipse-vertx/vert.x/issues/1920\" target=\"_blank\" rel=\"noopener\">exlipse-vertx/vert.x - issue#1920</a></p>\n</li>\n<li><p><a href=\"http://reactivex.io/documentation/single.html\" target=\"_blank\" rel=\"noopener\">Reactivex Java - Single</a></p>\n</li>\n<li><p><a href=\"http://reactivex.io/documentation/subject.html\" target=\"_blank\" rel=\"noopener\">Reactivex Java - Subject</a></p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h1 id=\"引子\"><a href=\"#引子\" class=\"headerlink\" title=\"引子\"></a>引子</h1><p>这是一个晴朗的午后，我沐浴着窗口洒落的阳光，懒洋洋地敲着代码，喝着并不存在的咖啡，听着窗外并不存在的熙熙攘攘。这是一个疫情中的午后，深圳二月份的天气算是比较厚道，一件薄外套已经让我微微出汗。我，又遇到bug了，调了一上午的bug，自己写的bug，查了半天的bug，甚至让我分不清此刻的汗水是气温还是bug导致的。</p>\n<p>随着时间的流逝，bug终究会解决，我们要做的，就是静静地等着。不知不觉已经到了晚上，果然，bug解决了。往往一个bug的持续时间决定了它是否值得被记录。解决完这个bug时，我惊喜地意识到又可以水一篇博文了。呵呵。</p>","more":"<p>在Vert.x中，Future是遵循Promise/Future原则的接口，是一个占位符。按官方说的，它代表了一个可能已经发生、或可能还没发生的动作的结果，即一个异步结果。读取其中的结果，通常是设置一个回调方法，但是注意，<strong>一个future只能设置一个回调方法，即一个Handler，或者更具体地说，如果设置多个Handler，则只有最后一个Handler有效。</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> future = Promise.promise&lt;String&gt;().future();</span><br><span class=\"line\">future.setHandler &#123; ar -&gt; </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(ar.failed())&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 处理失败的情况</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 处理成功的情况</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"事故回放\"><a href=\"#事故回放\" class=\"headerlink\" title=\"事故回放\"></a>事故回放</h1><h2 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h2><p>有一缓存需求：将一段读取数据库的代码的结果缓存起来，缓存有效期十分钟，过期后自动刷新，要求整个过程全异步。</p>\n<p>为了后期能够随时更换缓存实现，于是抽闲出如下缓存接口</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Cache</span>&lt;<span class=\"type\">K, V</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// get方法，第一个参数为key，第二个参数为缓存过期时获取新的缓存的方法</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">get</span><span class=\"params\">(key: <span class=\"type\">K</span>, mappingFunction: () -&gt; <span class=\"type\">Future</span>&lt;<span class=\"type\">V</span>&gt;)</span></span>: Future&lt;V&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 删除缓存值</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">invalidate</span><span class=\"params\">(key: <span class=\"type\">K</span>)</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>并使用Caffeine实现上述接口</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CaffeineProxy</span>&lt;<span class=\"type\">K, V</span>&gt;  : <span class=\"type\">Cache</span>&lt;<span class=\"type\">K, V</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> cache: Cache&lt;K, Future&lt;V&gt;&gt; = Caffeine.newBuilder().build()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">get</span><span class=\"params\">(key: <span class=\"type\">K</span>, mappingFunction: () -&gt; <span class=\"type\">Future</span>&lt;<span class=\"type\">V</span>&gt;)</span></span>: Future&lt;V&gt; = </span><br><span class=\"line\">    cache.<span class=\"keyword\">get</span>(key) &#123; mappingFunction.invoke() &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">invalidate</span><span class=\"params\">(key: <span class=\"type\">K</span>)</span></span> = cache.invalidate(key!!)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在<strong>协程上下文</strong>中使用，如下</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ServiceImpl</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> locationCache = LocationCache()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 由于只缓存一段代码的执行结果，因此只有一个key，用一个内部类将缓存包裹起来</span></span><br><span class=\"line\">    <span class=\"keyword\">inner</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LocationCache</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建缓存实例</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> innerCache = CaffeineProxy&lt;String, List&lt;Location&gt;&gt;()</span><br><span class=\"line\">    <span class=\"comment\">// 取值方法，取的结果是Future实例</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getCache</span><span class=\"params\">()</span></span>: Future&lt;List&lt;JsonObject&gt;&gt; = innerCache.<span class=\"keyword\">get</span>(<span class=\"string\">\"UniqueCache\"</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> promise = Promise.promise&lt;List&lt;JsonObject&gt;&gt;()</span><br><span class=\"line\">\t\tadminDao.getAvailableLocations(promise)</span><br><span class=\"line\">        promise.future()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"comment\">// 在方法1中使用该缓存</span></span><br><span class=\"line\">  <span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">fun1</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">val</span> result = locationCache.getCache().await()</span><br><span class=\"line\">      . . .  后续操作 . . .</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"comment\">// 在方法2中使用该缓存</span></span><br><span class=\"line\">  <span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">fun2</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">val</span> result = locationCache.getCache().await()</span><br><span class=\"line\">      . . .  后续操作 . . .</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"问题复现\"><a href=\"#问题复现\" class=\"headerlink\" title=\"问题复现\"></a>问题复现</h2><p>并发较高的场景下，会出现部分方法调用无响应的情况。上述缓存方法放在Web代码中，对应的就是多个会用到缓存的请求同时发起时，部分请求会永远无响应，或者触发系统的超时机制。</p>\n<h2 id=\"原因分析\"><a href=\"#原因分析\" class=\"headerlink\" title=\"原因分析\"></a>原因分析</h2><p>上述缓存有一个大前提，即将Future缓存起来，并在之后的流通中反复使用同一个被缓存的Future。前文中，我们在协程上下文中调用了Future的await()方法，该方法定义如下。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Awaits the completion of a future without blocking the event loop.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> Future<span class=\"type\">&lt;T&gt;</span>.<span class=\"title\">await</span><span class=\"params\">()</span></span>: T = <span class=\"keyword\">when</span> &#123;</span><br><span class=\"line\">  succeeded() -&gt; result()</span><br><span class=\"line\">  failed() -&gt; <span class=\"keyword\">throw</span> cause()</span><br><span class=\"line\">  <span class=\"keyword\">else</span> -&gt; suspendCancellableCoroutine &#123; cont: CancellableContinuation&lt;T&gt; -&gt;</span><br><span class=\"line\">    setHandler &#123; asyncResult -&gt;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (asyncResult.succeeded()) cont.resume(asyncResult.result() <span class=\"keyword\">as</span> T)</span><br><span class=\"line\">      <span class=\"keyword\">else</span> cont.resumeWithException(asyncResult.cause())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，其逻辑是：如果成功则返回结果；如果失败则抛出异常；Future未完成则调用setHandler()设置回调方法。</p>\n<p>再来看看Future的实现FutureImpl的定义</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FutureImpl</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Promise</span>&lt;<span class=\"title\">T</span>&gt;, <span class=\"title\">Future</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> failed;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> succeeded;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Handler&lt;AsyncResult&lt;T&gt;&gt; handler;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> T result;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Throwable throwable;</span><br><span class=\"line\">    </span><br><span class=\"line\">    . . . . . .</span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * Set a handler for the result. It will get called when it's complete</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Future&lt;T&gt; <span class=\"title\">setHandler</span><span class=\"params\">(Handler&lt;AsyncResult&lt;T&gt;&gt; handler)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> callHandler;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">      callHandler = isComplete();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!callHandler) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.handler = handler;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (callHandler) &#123;</span><br><span class=\"line\">      handler.handle(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">    . . . . . .</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，setHandler()会将传入的handler直接覆盖掉现有的handler属性。</p>\n<p>于是可以分析出正常情景和异常情景如下</p>\n<ul>\n<li><p>异常情景</p>\n<p>缓存已过期，此时方法1调用获取缓存方法，拿到Future，该Future未完成，于是通过await()方法调用setHandler()设置了一个回调方法；在缓存中的Future尚未完成前，方法2也调用获取缓存方法，得到同一个Future实例，同样，由于它未完成，于是通过await()方法再次调用setHandler()设置了新的回调方法。</p>\n<p>这样，方法2设置的回调方法覆盖了方法1设置的回调，当Future完成时，方法2的回调方法将得到通知，使得方法2能够正常继续执行；方法1的回调则会永远等待被回调，直到超时。</p>\n</li>\n<li><p>正常情景</p>\n<p>缓存有效，且Future已完成，根据await()方法的定义：先同步地读取Future的结果，在本场景中，一直能够读取到Future结果，而不会进入到setHandler()，这样无论并发多高，都能够正确返回结果。</p>\n</li>\n</ul>\n<p>如果缓存时间设置很长，Future从创建到完成的时间很短，在单元测试阶段甚至SIT都很难发现。很容易造成线上偶现的bug，并且相当地隐晦，可以说是非常难以发现了。</p>\n<h2 id=\"然后呢？\"><a href=\"#然后呢？\" class=\"headerlink\" title=\"然后呢？\"></a>然后呢？</h2><p>到这里，原因找到了。但是仔细想想，从语义上，Future代表一个异步执行的结果，常规的使用方法是setHandler()设置回调方法，那一个结果被多处使用似乎是很自然的需求，Vert.x设置这样一个限制，是不是有些反直觉，或者反人类呢？</p>\n<p>或许我们可以在这个<a href=\"https://github.com/eclipse-vertx/vert.x/issues/1920\" target=\"_blank\" rel=\"noopener\">issue</a>找到些许解释。简而言之，Future就这样了，如果需要一次生成多次使用，请考虑其它库来实现这样的效果，如RxJava。或者等Vert.x4中将会有类似功能的实现。</p>\n<p>我想吐槽的点在于，目前Vert.x的Future实现不修改没有问题，但做一些针对上述问题的防护措施也是可以的，可是并没有。</p>\n<h1 id=\"正确的做法\"><a href=\"#正确的做法\" class=\"headerlink\" title=\"正确的做法\"></a>正确的做法</h1><p>看来，Future是不能使用了，那我们应该使用什么呢？官方推荐使用RxJava，查看<a href=\"http://reactivex.io/documentation/subject.html\" target=\"_blank\" rel=\"noopener\">文档</a>后，发现有如下几个占位符可选。</p>\n<ul>\n<li>Single — Single.cache()生成的Single，可被多次订阅</li>\n<li>订阅Single的BehaviorSubject —— 可订阅和被订阅，用它订阅Single，我们再订阅它。特性上，它返回其订阅的最近的消息，并永远不会主动结束，即可被多次订阅</li>\n</ul>\n<p>二者综合选其一，肯定是能直接使用Single就直接使用Single就好呀。</p>\n<p>于是将我们的缓存实现修改成缓存Single的形式</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> * Cache接口</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Cache</span>&lt;<span class=\"type\">K, V</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// get方法，第一个参数为key，第二个参数为缓存过期时获取新的缓存的方法</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">get</span><span class=\"params\">(key: <span class=\"type\">K</span>, mappingFunction: () -&gt; <span class=\"type\">Single</span>&lt;<span class=\"type\">V</span>&gt;)</span></span>: Single&lt;V&gt;</span><br><span class=\"line\">  . . . . . .</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> * Cache实现</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CaffeineProxy</span>&lt;<span class=\"type\">K, V</span>&gt;  : <span class=\"type\">Cache</span>&lt;<span class=\"type\">K, V</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> cache: Cache&lt;K, Single&lt;V&gt;&gt; = Caffeine.newBuilder().build()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">get</span><span class=\"params\">(key: <span class=\"type\">K</span>, mappingFunction: () -&gt; <span class=\"type\">Single</span>&lt;<span class=\"type\">V</span>&gt;)</span></span>: Single&lt;V&gt; = </span><br><span class=\"line\">    cache.<span class=\"keyword\">get</span>(key) &#123; mappingFunction.invoke() &#125;</span><br><span class=\"line\">  . . . . . .</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用时获取Single并订阅即可。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ServiceImpl</span> </span>&#123;</span><br><span class=\"line\">    . . . . . .</span><br><span class=\"line\">    <span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">fun1</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        locationCache.getCache().subscribe(&#123; result -&gt;</span><br><span class=\"line\">        <span class=\"comment\">// 对成功的处理</span></span><br><span class=\"line\">        &#125;,&#123; cause -&gt;</span><br><span class=\"line\">            <span class=\"comment\">// 对失败的处理</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    . . . . . .</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"合适的做法\"><a href=\"#合适的做法\" class=\"headerlink\" title=\"合适的做法\"></a>合适的做法</h1><p>使用Single虽然实现了异步缓存的功能，但在协程中使用RxJava却是浪费了协程的特性。那如果我们在调用时想要使用Future呢。为此可以将缓存包装一下，同时暴露协程、Future、Single三种API风格的接口，任君选择。</p>\n<p>接口如下</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">CacheProxy</span>&lt;<span class=\"type\">K, V</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Single API</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">singleGet</span><span class=\"params\">(key: <span class=\"type\">K</span>, mappingFunction: () -&gt; <span class=\"type\">Single</span>&lt;<span class=\"type\">V</span>&gt;)</span></span>: Single&lt;V&gt;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// Future API </span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">futureGet</span><span class=\"params\">(key: <span class=\"type\">K</span>, mappingFunction: () -&gt; <span class=\"type\">Future</span>&lt;<span class=\"type\">V</span>&gt;)</span></span>: Future&lt;V&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 协程API</span></span><br><span class=\"line\">  <span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">coroutineGet</span><span class=\"params\">(key: <span class=\"type\">K</span>, mappingFunction: <span class=\"type\">suspend</span> () -&gt; <span class=\"type\">V</span>)</span></span>: V</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实现类可以这么做。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CaffeineProxy</span>&lt;<span class=\"type\">K, V</span>&gt;</span>(<span class=\"keyword\">val</span> vertx: Vertx) : CacheProxy&lt;K, V&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> cache: Cache&lt;K, Single&lt;V&gt;&gt; = Caffeine.newBuilder().build()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 接收返回Single的方法，返回一个Single</span></span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">singleGet</span><span class=\"params\">(key: <span class=\"type\">K</span>, mappingFunction: () -&gt; <span class=\"type\">Single</span>&lt;<span class=\"type\">V</span>&gt;)</span></span>: Single&lt;V&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cache.<span class=\"keyword\">get</span>(key!!) &#123; mappingFunction.invoke() &#125;!!</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 接收返回Future的方法，返回一个Future</span></span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">futureGet</span><span class=\"params\">(key: <span class=\"type\">K</span>, mappingFunction: () -&gt; <span class=\"type\">Future</span>&lt;<span class=\"type\">V</span>&gt;)</span></span>: Future&lt;V&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> promise = Promise.promise&lt;V&gt;()</span><br><span class=\"line\">    cache.<span class=\"keyword\">get</span>(key) &#123; SingleHelper.toSingle&lt;V&gt; &#123; mappingFunction.invoke().setHandler(it) &#125;.cache() &#125;!!.subscribe(&#123;</span><br><span class=\"line\">      promise.complete(it)</span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">      promise.fail(it)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> promise.future()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 接收suspend方法，返回一个值</span></span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">coroutineGet</span><span class=\"params\">(key: <span class=\"type\">K</span>, mappingFunction: <span class=\"type\">suspend</span> () -&gt; <span class=\"type\">V</span>)</span></span> = withContext(vertx.dispatcher()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> promise = Promise.promise&lt;V&gt;()</span><br><span class=\"line\">    cache.<span class=\"keyword\">get</span>(key) &#123;</span><br><span class=\"line\">      Single.create&lt;V&gt; &#123;</span><br><span class=\"line\">        launch &#123;</span><br><span class=\"line\">          <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            it.onSuccess(mappingFunction.invoke())</span><br><span class=\"line\">          &#125; <span class=\"keyword\">catch</span> (e: Exception) &#123;</span><br><span class=\"line\">            it.onError(e)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;.cache()</span><br><span class=\"line\">    &#125;!!.subscribe(&#123;</span><br><span class=\"line\">      promise.complete(it)</span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">      promise.fail(it)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    promise.future().await()</span><br><span class=\"line\">  &#125;!!</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Rx风格的接口不必多说，直来直去；</p>\n<p>Future风格的接口，使用了Vert.x提供的API在Single和Future之间进行了切换；协程会稍微麻烦点：</p>\n<p>协程内部可以看做是同步执行的，在获取Single时，为了全异步特性，我们需要异步执行，因此使用launch启动新协程是个好办法。</p>\n<p>至此，我们的缓存接口能够适用于目前所有三种异步API，使用时无缝衔接。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>Future多次使用的问题，并不是我第一次遇到，只不过上次主要是靠前辈解决，以至于过了太久我都没什么印象，说来确实不太应该。</p>\n<p>但好在问题解决了，同时也提出了一种通用的调用方法，在实用层面上，是值得参考的。</p>\n<h1 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h1><ol>\n<li><p><a href=\"https://vertx.io/docs/vertx-core/java/\" target=\"_blank\" rel=\"noopener\">Vert.x官方手册 - 核心部分</a></p>\n</li>\n<li><p><a href=\"https://github.com/eclipse-vertx/vert.x/issues/1920\" target=\"_blank\" rel=\"noopener\">exlipse-vertx/vert.x - issue#1920</a></p>\n</li>\n<li><p><a href=\"http://reactivex.io/documentation/single.html\" target=\"_blank\" rel=\"noopener\">Reactivex Java - Single</a></p>\n</li>\n<li><p><a href=\"http://reactivex.io/documentation/subject.html\" target=\"_blank\" rel=\"noopener\">Reactivex Java - Subject</a></p>\n</li>\n</ol>"}],"PostAsset":[],"PostCategory":[{"post_id":"clxpkfzye008mnwi1hh7v0r27","category_id":"clxpjqcxc003yj6i1bhwifu7q","_id":"clxpkfzyf008onwi10ka5th3e"}],"PostTag":[{"post_id":"clxpkfzye008mnwi1hh7v0r27","tag_id":"clxpjqcxg005bj6i1wpccm687","_id":"clxpkfzye008nnwi1h67pi8j4"}],"Tag":[{"name":"celery","_id":"clxpjqcvk0005j6i1c2lg67mk"},{"name":"JOOQ","_id":"clxpjqcvm000aj6i1ee0g9on5"},{"name":"支付宝","_id":"clxpjqcvr000lj6i1dywdrxtk"},{"name":"微信","_id":"clxpjqcvt000rj6i1z3linj0r"},{"name":"京东","_id":"clxpjqcvv000sj6i1ralrgzy7"},{"name":"银联","_id":"clxpjqcvx000uj6i1p4o7zs7w"},{"name":"supervisor","_id":"clxpjqcvy000vj6i14qjhz1uq"},{"name":"进程管理","_id":"clxpjqcw0000yj6i10xicjm2i"},{"name":"fileupload","_id":"clxpjqcwi001aj6i1daa3v74j"},{"name":"apache","_id":"clxpjqcwj001gj6i1l2cmaop2"},{"name":"Git","_id":"clxpjqcwj001lj6i1xbydleaj"},{"name":"kotlin","_id":"clxpjqcwk001sj6i18a2z4pzw"},{"name":"协程","_id":"clxpjqcwl001yj6i16ut3bn48"},{"name":"kubernetes","_id":"clxpjqcwm0025j6i1jdbn9twx"},{"name":"日志","_id":"clxpjqcwy003ej6i1096esrgl"},{"name":"postresql","_id":"clxpjqcx3003lj6i1rtfl1aah"},{"name":"Spring","_id":"clxpjqcx6003qj6i1ppi1y1k9"},{"name":"Webflow","_id":"clxpjqcx9003wj6i1ik5mz9ib"},{"name":"问题记录","_id":"clxpjqcxg0051j6i1vxdvqpgy"},{"name":"pipenv","_id":"clxpjqcxg0056j6i1bfufxf3m"},{"name":"Vert.x","_id":"clxpjqcxg005bj6i1wpccm687"},{"name":"IOS","_id":"clxpjqcxg005nj6i1n3zuw3gt"},{"name":"DNS","_id":"clxpjqcxh005uj6i1tz9x8amx"},{"name":"django","_id":"clxpjqcxh005yj6i1yieel47x"},{"name":"akka","_id":"clxpjqcxh006aj6i1yf6m5hna"},{"name":"Maven","_id":"clxpjqcxh006gj6i15jg9ptu2"},{"name":"随笔","_id":"clxpjqcxh006kj6i1g2w6ymo0"},{"name":"博客","_id":"clxpjqcxh006pj6i18wqk3gqp"},{"name":"Angular","_id":"clxpjqcxh006rj6i1ph7gcbcv"},{"name":"Vue","_id":"clxpjqcxi006vj6i1cffvoyzg"},{"name":"React","_id":"clxpjqcxi006yj6i12wtnwfon"},{"name":"Sock JS","_id":"clxpjqcxi0076j6i12z7u27qo"},{"name":"浏览器指纹","_id":"clxpjqcxi007cj6i17vxu4jql"},{"name":"time","_id":"clxpjqcxi007hj6i1zhy8bqm3"},{"name":"Flag","_id":"clxpjqcxi007mj6i15xgnqsy6"},{"name":"自省","_id":"clxpjqcxi007pj6i1uyr7ixm8"},{"name":"推荐","_id":"clxpjqcxi007qj6i1sqiwcvws"},{"name":"长尾","_id":"clxpjqcxi007tj6i19wjbwk8i"},{"name":"马太效应","_id":"clxpjqcxi007uj6i1hdmwsvsx"},{"name":"Nginx","_id":"clxpjqcxi007vj6i1zxb6kbks"},{"name":"协同过滤","_id":"clxpjqcxi007yj6i1gln7z5ix"},{"name":"NIO","_id":"clxpjqcxj0081j6i1moho7mrg"},{"name":"HTTP","_id":"clxpjqcxj0083j6i14ctguwqj"},{"name":"frp","_id":"clxpjqcxj0085j6i1h2uadmzy"},{"name":"RxJava","_id":"clxpjqcxj0087j6i1vjejdlrz"},{"name":"Prometheus","_id":"clxpjqcxj0089j6i1c6yij14w"},{"name":"Grafana","_id":"clxpjqcxj008bj6i1m5ih39xy"}]}}